<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mongoDB相关操作]]></title>
    <url>%2F2019%2F04%2F08%2FmongoDB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[依旧是一段前言，博客好久没更新了，但其实每天都在积累，现在已积累了一些markdown文档，后续整理下会放上来；另一个原因是，一直在考虑换一个博客主题，hugo或者是gatsby，现正在研究中~ ;还有一个便是换了台新设备，近来的学习都在新设备上搭建，因为要更新博客主题，所以也就没有给新设备上安装hexo环境… 本文是有关mongodb一些基础知识积累，算是一个学习笔记，希望对你有帮助，对我也是加深记忆。目前还在学习更新中~ 数据库分类关系型数据库 (RDBMS) 关系型数据库中全都是表 (MySql/Oracle/DB2/Sql Server) 非关系型数据库(NoSql Not only sql) 键值对表(Mongodb/Redis) 修改mongod 数据存放位置 mongod --dbpath usr/local/data mac环境安装与配置mongodb数据库数据库的服务器： 服务器用来保存数据 mongod用来启动服务器 数据库的客户端： 客户端用来操作服务器，对数据进行增删改查操作 mongo用来启动客户端 将mongodb设为系统服务，自动在后台启动，不需要每次都手动启动 基本概念数据库(database)集合(collection)文档(document) 基本指令显示当前的所有数据库12show dbsshow database use 数据库名(进入到指定的数据库中)db (db表示当前所处的数据库) 显示数据库中所有的集合show collections 向数据库中CRUD(增删改查)的操作向数据库中插入文档db.&lt;collection&gt;.insert(doc) 向集合中插入一个或多个文档 例子：向test数据库中的students集合中插入一个新的学生对象 插入一个文档：db.students.insert({&quot;name&quot;:&quot;daguo&quot;,&quot;age&quot;:&quot;27&quot;,&quot;sex&quot;:&quot;man&quot;}) 插入多个文档：1234db.students.insert([ &#123;&quot;name&quot;:&quot;daguo&quot;,&quot;age&quot;:&quot;27&quot;,&quot;sex&quot;:&quot;man&quot;&#125;, &#123;&quot;name&quot;:&quot;daguo&quot;,&quot;age&quot;:&quot;27&quot;,&quot;sex&quot;:&quot;man&quot;&#125;]) 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id,该属性用来作为文档的唯一标识 插入一个文档对象：db.collection.insertOne()插入多个文档对象：db.collection.insertMany() use test 查询db.&lt;collection&gt;.find() 查询当前集合中的所有文档 find({}) 表示查询集合中的所有文档 find({属性：值}) 查询属性是指定值的文档 find() 返回的是一个数组 db.students.find({name:&#39;winter&#39;}) db.collection.findOne() 用来查询集合中符合条件的第一个文档 findOne()返回的是一个文档对象 db.collection.find().count() db.collection.find().length() 查询所有结果的数量 更新/修改db.collection.update(查询条件,新对象) update默认情况下会使用新对象来替换旧对象 如果需要修改指定的属性，而不是替换，需要使用修改操作符来完成修改 $set用来修改文档中的指定属性 $unset可以用来删除文档的指定属性 db.collection.updateMany() 同时修改多个符合条件的文档 db.collection.updateOne() 修改一个符合条件的文档 删除一般数据库中的数据都不会删除，所以删除的方法很少调用 一般会在数据中添加一个字段，用来表示数据是否被删除 db.collection.remove() 删除符合条件的所有文档（默认情况下会删除多个） 如果remove({},true) 第二个参数传递一个true,则只会删除一个 1db.colletion.remove(&#123;name:&apos;李四&apos;&#125;) db.collection.deleteOne() db.collection.deleteMany() db.collection.drop() 删除集合 db.collection.dropDatabase() 删除数据库 清空集合 db.collection.remove({}) 性能较差 db.collection.drop() 安装mongodb图形化管理工具mongodbmanager 貌似只有windows版本 MongoChef 安装包较大 mongodb compass 最终选择它，mongodb官方GUI dbkoda mongodb操作数据库一些例子1.进入my_test数据库use my_test 2.向数据库users集合中插入一个文档db.users.insert({name:&#39;daguo&#39;,age:&#39;25&#39;,address:&#39;shanxi&#39;,location:&#39;hangzhou&#39;}) 3.查询users集合中的文档db.users.find() 4.向数据库users集合中插入一个文档步骤同2 5.查询数据库users集合中的文档步骤同3 6.查询数据库users集合中的文档数量db.users.find().count() or db.users.find().length() 7.查询数据库users集合中name为daguo的文档db.users.find({name:&#39;daguo&#39;}) 8.向数据库users集合中的name为daguo的文档，添加一个address属性，属性值为hangzhoudb.users.find({name:&#39;daguo&#39;},{$set:{address:&#39;hangzhou&#39;}}) 9.使用{name:’gwt’}替换name 为daguo的文档db.users.replaceOne({name:&#39;daguo&#39;},{name:&#39;gwt&#39;}) 10.删除name为daguo的文档的address属性db.users.update({name:&#39;daguo&#39;},{$unset:{address:&#39;&#39;}}) 11.向name为daguo的文档中，添加一个hobby:{cities:[‘beijing’,’shanghai’,’hangzhou’],movies:[‘sanguo’,’hero’]}//mongodb的文档的属性值也可以是一个文档，当一个文档的属性值是另一个文档时，我们称这个文档叫做内嵌文档 db.users.update({name:&#39;daguo&#39;},{$set:{hobby:{cities:[&#39;beijing&#39;,&#39;shanghai&#39;,&#39;hangzhou&#39;],movies:[&#39;sanguo&#39;,&#39;hero&#39;]}}}) 12.向name为gwt的文档中，添加一个hobby:{movies:[“长城”,”大黄蜂”]}db.users.update({name:&#39;gwt&#39;},{$set:{hobby:{movies:[&quot;长城&quot;,&quot;大黄蜂&quot;]}}}) 13.查询喜欢电影hero的文档// mongodb 支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档，则可以通过.的形式来匹配 // 如果要通过内嵌文档来对文档进行查询，此时属性名必须要使用引号 db.users.find({&quot;hobby.movies&quot;:&quot;hero&quot;}) 14.向gwt中添加一个新的电影 绿皮书// $push用于向数组中添加一个新的元素 // $addToSet 向数组中添加一个新元素，如果数组中已经存在了该元素，则不会添加 db.users.update({name:&#39;gwt&#39;},{$push:{&quot;hobby.movies&quot;:&quot;绿皮书&quot;}})db.users.update({name:&#39;gwt&#39;},{$addToSet:{&quot;hobby.movies&quot;:&quot;绿皮书&quot;}}) 15.删除喜欢beijing的用户db.users.remove({&quot;hobby.cities&quot;:&quot;beijing&quot;}) 16.删除users集合db.users.remove({}) db.users.drop() 17.向numbers中插入20000条数据//7.2s 性能较低123for(var i = 1;i&lt;= 2000;i++)&#123; db.numbers.insert(&#123;num:i&#125;)&#125; // 只插入一次方法 0.4s 12345var arr = [];for (var i = 1;i&lt;= 2000;i++)&#123; arr.push(&#123;num:i&#125;)&#125;db.numbers.insert(arr) 18.查询numbers中num为500的文档db.numbers.find({num:500}) 19.查询numbers中num大于5000的文档// $gt 大于 $gte 大于等于 db.numbers.find({num:{$gt:5000}}) 20.查询numbers中num小于30的文档db.numbers.find({num:{$lt:30}}) 21.查询numbers中num大于19996的文档db.numbers.find({num:{$gt:19996}}) 22.查询numbers中num大于40小于50的文档db.numbers.find({num:{$gt:40,$lt:50}}) 23.查看numbers集合中的前10条数据db.numbers.find({num:{$lte:10}}) //limit()设置显示数据的上限db.numbers.find().limit(10)//在开发时，绝对不会执行不带条件的查询db.numbers.find() 24.查看numbers集合中的第11条到20条数据//skip() 用于跳过指定数量的数据 limit()每页显示的条数‘//mongodb会自动调整skip和limit的位置db.numbers.find().skip(10).limit(10) 25.查看numbers集合中的第21条到30条数据db.numbers.find().slip(20).limit(10)db.numbers.find().limit(10).slip(20) 26.将dept和emp集合导入到数据库中向集合中倒入dept.json和emp.json文件 27.查询工资小于2000的员工db.emp.find({sal:{$lt:2000}}) 28.查询工资在1000——2000之间的员工db.emp.find({sal:{$gt:1000,$lt:2000}) 29.查询工资小于1000或者大于2500的员工db.emp.find({$or:[{sal:{$lt:1000}},{sal:{$gt:2500}}]}) 30.查询财务部的所有员工12var depno = de.dept.find(&#123;dname:&apos;财务部&apos;&#125;).deptno;db.emp.find(&#123;depno:depno&#125;) 31.查询销售部的所有员工12var depno = de.dept.find(&#123;dname:&apos;销售部&apos;&#125;).deptno;db.emp.find(&#123;depno:depno&#125;) 32.查询所有mgr为7698的员工db.emp.find({mgr:7698}) 33.为所有薪资低于1000 的员工加工资400元// $inc自增db.emp.updateMany({sal:{$lt:1000}},{$inc:{sal:400}}) 文档之间的关系一对一(one to one) 夫妻——一个丈夫对应一个妻子，在mongodb中，可以通过内嵌文档的关系来体现出一对一的关系 1db.wifeAndHusband.insert([&#123;name:&apos;冯绍峰&apos;,wife:&#123;name:&apos;赵丽颖&apos;&#125;&#125;,&#123;name:&apos;黄晓明&apos;,wife:&#123;name:&apos;杨颖&apos;&#125;&#125;]) 一对多(one to many / many to one )用户和订单 123456789101112db.users.insert([&#123;name:&apos;swk&apos;&#125;,&#123;name:&apos;zbj&apos;&#125;])swk: user_id: ObjectId(&quot;5ca9fd0da653d9e932f76b0e&quot;)zbj: user_id: ObjectId(&quot;5ca9fd5ca653d9e932f76b0f&quot;)db.orders.insert(&#123;list: [&apos;苹果&apos;,&apos;香蕉&apos;,&apos;菠萝&apos;,&apos;凤梨&apos;],user_id: ObjectId(&quot;5ca9fd0da653d9e932f76b0e&quot;)&#125;)db.orders.insert(&#123;list:[&apos;凉皮&apos;,&apos;肉夹馍&apos;,&apos;碗团&apos;],user_id:ObjectId(&quot;5ca9fd5ca653d9e932f76b0f&quot;)&#125;)db.orders.insert(&#123;list:[&apos;扬州炒饭&apos;,&apos;西湖醋鱼&apos;,&apos;糖醋排骨&apos;],user_id:ObjectId(&quot;5ca9fd0da653d9e932f76b0e&quot;)&#125;)//查找孙悟空的订单var user_id = db.users.findOne(&#123;name:&apos;swk&apos;&#125;)._id;db.orders.find(&#123;user_id:user_id&#125;) 多对多(many to many)老师-学生之间的关系 123456789db.teachers.insert([ &#123;name:&apos;郭德纲&apos;&#125;, &#123;name:&apos;于谦&apos;&#125;, &#123;name:&apos;冯小刚&apos;&#125;])db.students.insert([&#123;name:&apos;岳云鹏&apos;,teac_id:[ObjectId(&quot;5cac8e64cd9487edaff8ba61&quot;),ObjectId(&quot;5cac8e64cd9487edaff8ba62&quot;)]&#125;,&#123;name:&apos;张云雷&apos;,teac_id:[ObjectId(&quot;5cac8e64cd9487edaff8ba62&quot;)]&#125;,&#123;name:&apos;郑恺&apos;,teac_id:[ObjectId(&quot;5cac8e64cd9487edaff8ba63&quot;)]&#125;])var teac_id = db.teachers.findOne(&#123;name:&apos;于谦&apos;&#125;)._id; db.students.find(&#123;teac_id:teac_id&#125;) sort和投影// 查询文档时，默认是按照_id进行排序// sort() 可以指定文档的排序规则 sort()中需要传递一个对象来指定排序规则 1表示升序 -1表示降序// limt() skip() sort() 可以以任意的顺序进行调用db.numbers.find().sort({num:-1})db.numbers.find().sort({num:-1,aa:1}) //可以指定多个排序规则 // 在查询时，可以在第二个参数的位置来设置查询结果的投影可以显示想展示的字段 0表示隐藏 1表示显示db.numbers.find({},{name:1}) //只展示name的结果 db.numbers.find({},{name:1,_id:0}) //只展示name的结果 mongoose(https://mongoosejs.com/)Schema(约束数据库中的文档结构) Model(相当于collection) Document 1.下载安装mongoosecnpm install mongoose --save 2.在项目中引入mongoosevar mongoose = require(&#39;mongoose&#39;) 3.连接mongodb数据库123mongoose.connect(&apos;mongodb://数据库的ip地址：端口号/数据库名&apos;,&#123;useMongoClient:true&#125;)-- 如果端口号是27017(mongodb默认端口号) 则可以忽略不及 4.断开数据库连接(一般不需要调用)mongodb数据库，一般情况下，只需要连接一次，连接一次之后，除非项目停止/服务器关闭，否则连接一般不会断开mongoose.disconnect() 监听MongoDb数据库的连接状态 在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接 通过监听该对象的状态，可以来监听数据库的连接与断开 123456789数据库连接成功的事件mongoose.connection.once(&apos;open&apos;,function()&#123;&#125;)数据库断开的事件mongoose.connection.once(&apos;close&apos;,function()&#123;&#125;) 向数据库中插入文档（增加）123456789101112131415161718192021222324252627282930313233343536373839var mongoose = require(&apos;mongoose&apos;);// 连接数据库mongoose.connect(&apos;mongodb://127.0.0.1:27017/mongoose_test&apos;,&#123;useNewUrlParser: true&#125;);mongoose.connection.once(&apos;open&apos;,function()&#123; console.log(&apos;数据库连接成功～&apos;);&#125;)// 将mongoose.Schema 赋值给一个变量var Schema = mongoose.Schema;// 创建Schema模式对象var StuSchema = new Schema(&#123; name: String, age: Number, gender: &#123; type: String, default: &apos;female&apos; &#125;, address: String&#125;)// 通过Schema来创建Model// Model代表数据库中的集合，通过Model才能对数据库进行操作// mongoose.model(modelName, schema);// modelName 代表映射的结合名 mongoose会自动将集合变为复数var StuModel = mongoose.model(&quot;student&quot;,StuSchema)// 向数据库中插入一个文档// StuModel.create(doc,function(err)&#123;&#125;)StuModel.create(&#123; name: &apos;郭德纲&apos;, age: 44, gender: &apos;male&apos;, address: &apos;浙江省杭州市西湖区&apos;&#125;,function(err)&#123; if(!err)&#123; console.log(&apos;文档插入成功～&apos;); &#125;&#125;) 数据库查询参考文档：https://mongoosejs.com/docs/guide.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var StuModel = mongoose.model(&quot;student&quot;,stuSchema);/* 有了Model就可以对数据库进行增删改查的操作了 Model.create(doc(s),[callback]) 用来创建一个或多个文档，并添加到数据库中 参数： doc(s) 可以是一个文档对象，也可以是一个文档对象的数组 callback 当操作完成以后调用的回调函数 查询的： Model.find(conditions,[projection],[options],[callback]) - 查询所有符合条件的文档 总会返回一个数组 Model.findById(id,[projection],[options],[callback]) - 根据文档的id属性查询文档 Model.findOne([conditions],[projection],[options],[callback]) - 查询符合条件的第一个文档 总会返回一个具体对象 conditions 查询的条件 projection 投影 - 两种方式 &#123;name:1,_id:0&#125; &quot;name -_id&quot; options 查询选项(skip limit) callback 回调函数，查询结果会通过回调函数返回 回调函数必须传递，否则将不会查询*/StuModel.create([],function(err)&#123; if(!err)&#123; console.log(&apos;文档插入成功~&apos;); &#125;&#125;)StuModel.find(&#123;&#125;,function(err,docs)&#123; if(!err)&#123; console.log(docs); &#125;&#125;)//输出结果(将该表所有结果返回)[&#123;_id:,name:&apos;孙悟空&apos;,age:18,address:&apos;花果山&apos;,_v:0,gender:&apos;male&apos;&#125;,&#123;_id:,name:&apos;沙和尚&apos;,age:28,address:&apos;流沙河&apos;,_v:0,gender:&apos;male&apos;&#125;]StuModel.find(&#123;&#125;,&#123;name:1,_id:0&#125;,function(err,docs)&#123; if(!err)&#123; console.log(docs); &#125;&#125;)//输出结果(返回文档只包含字段name) name:1 name显示 _id:0 _id隐藏[&#123;name:&apos;孙悟空&apos;&#125;,&#123;name:&apos;白骨精&apos;&#125;,&#123;name:&apos;猪八戒&apos;&#125;,&#123;name:&apos;沙和尚&apos;&#125;]StuModel.find(&#123;&#125;,&quot;name age -_id&quot;,function(err,docs)&#123; if(!err)&#123; console.log(docs); &#125;&#125;)//输出结果 -_id代表_id属性隐藏[&#123;name:&apos;孙悟空&apos;,age:18&#125;,&#123;name:&apos;白骨精&apos;,age:16&#125;,&#123;name:&apos;猪八戒&apos;,age:28&#125;,&#123;name:&apos;沙和尚&apos;,age:38&#125;] 数据库修改1234567891011121314151617181920212223242526272829/* 修改 Model.update(conditions,doc,[options],[callback]) Model.updateMany(conditions,doc,[options],[callback]) Model.updateOne(conditions,doc,[options],[callback]) 用来修改一个或多个文档 参数： conditions 查询条件 doc 修改后的对象 [options] 配置参数 callback 回调函数 Model.repalceOne(conditions,doc,[options],[callback]) */// 修改郭德纲的地址为天津市// StuModel.updateOne(&#123;name:&apos;郭德纲&apos;&#125;,&#123;$set:&#123;address:&apos;天津市&apos;&#125;&#125;,function(err)&#123;// if(!err)&#123;// console.log(&apos;修改成功！&apos;);// &#125;// &#125;)// StuModel.updateOne(&#123;_id:&apos;5cb2887033358d0babf3fe6f&apos;&#125;,&#123;$set:&#123;name:&apos;赵本山&apos;&#125;&#125;,function(err)&#123;// if(!err)&#123;// console.log(&apos;修改成功～&apos;);// &#125;else&#123;// console.log(err);// &#125;// &#125;) 数据库删除123456789101112131415161718192021222324252627282930/* 删除 Model.remove(conditions,[callback]) Model.deleteOne(conditions,[callback]) Model.deleteMany(conditions,[callback])*/// StuModel.create([// &#123;// name: &apos;吴京&apos;,// age: 34,// gender: &apos;male&apos;,// address: &apos;北京市朝阳区&apos;// &#125;,&#123;// name: &apos;陈道明&apos;,// age: 61,// gender: &apos;male&apos;,// address: &apos;贵州市&apos;// &#125;// ],function(err)&#123;// if(!err)&#123;// console.log(&apos;文档插入成功～&apos;);// &#125;// &#125;)// StuModel.remove(&#123;name:&apos;王铁锤&apos;&#125;,function(err)&#123;// if(!err)&#123;// console.log(&apos;删除文档成功～&apos;)// &#125;// &#125;) 文档的属性和方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// var stu = new StuModel(&#123;// name: &apos;岳云鹏&apos;,// age: &apos;35&apos;,// gender: &apos;male&apos;,// address: &apos;河南省商丘市&apos;// &#125;)/* document方法 Model#save([options],fn)*/// stu.save(function(err)&#123;// if(!err)&#123;// console.log(&apos;保存成功～&apos;)// &#125;// &#125;)StuModel.findOne(&#123;&#125;,function(err,doc)&#123; if(!err)&#123; // console.log(doc); /* update(update,[options],[callback]) - 修改对象 remove([callback]) - 删除对象 */ // doc.update(&#123;$set:&#123;age:25&#125;&#125;,function(err)&#123; // if(!err)&#123; // console.log(&apos;修改成功～&apos;); // &#125; // &#125;) // doc.name = &apos;gwt&apos;; // doc.save() // doc.remove(function(err)&#123; // if(!err)&#123; // console.log(&apos;删除成功！&apos;); // &#125; // &#125;) /* get(name) - 获取文档中的指定属性值 set() - 设置文档的指定属性值 id - 获取文档的属性值 toJSON() - 转换为一个JSON对象 toObject() - 将Document转换为一个普通的JS对象 转换为普通的JS对象之后，所有的Document对象的方法或者属性就不能使用了 */ // console.log(doc.get(&apos;name&apos;)); // console.log(doc.name); // doc.set(&quot;name&quot;,&quot;daguo&quot;); //数据库中值不变 // doc.name = &apos;gwd&apos; // console.log(doc); // console.log(doc.id); // console.log(doc._id); var o = doc.toObject(); console.log(o); console.log(o.id) //undefined console.log(o._id); delete o.address; console.log(o); &#125;&#125;) 公用模块封装连接数据库/创建模型对象 mongodb/models/student.js mongodb/tools/con_mongo.js]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结果与过程]]></title>
    <url>%2F2019%2F01%2F13%2F%E7%BB%93%E6%9E%9C%E4%B8%8E%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[《碟中谍全面瓦解》中有这么一段台词，主角遇到问题总是会说一句：“我会想办法”，留下其余人一脸懵。感觉什么样的困难在他那里总是能够解决，虽然剧情的走向由编剧来定，结局问题一定是被解决掉了。但是，现实生活中，又有多少人有这样的勇气？ 现今是一个注重结果的时代，没有人会关心你的过程，（越发觉得前辈的经验往往过了一两年之后才会在你的身上应验）没有人会去关注实现结果的过程你有多痛苦，大家总是期望遇到大圆满的结局。就如项目开发中，没人关心你加班到几点、用什么方式去实现，他们希望看到的是项目如期且没有bug上线~ 而在我这微小的人生经验中，越发感到，大多数事只要投入足够多的时间，发生的概率还是很大的。只是取决于你想吃的是“营养液”，还是每日三餐这样一口一口的吃完；没明白？事物是公平的，要想短期内达到效果，必然是每天都投入大量时间，这样会牺牲很多日常生活，不过是见效最快的方式。而想一步步达到目标，必然是每天投入一点，每天投入一点，这样日积月累，你也总能实现目标，只是时间上比前者多~ intersting! 有趣的过程，选择权其实一直在我们手中~]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年来了！]]></title>
    <url>%2F2019%2F01%2F01%2F2019%E5%B9%B4%E6%9D%A5%E4%BA%86%EF%BC%81%2F</url>
    <content type="text"><![CDATA[今天的跨年感尤为强烈，以往都是农历新年的时候才会有过年的感觉，今年公历年就满满的又过了一年之感。过了凌晨，小区周边在放礼花，各大直播APP也都是跨年晚会的倒计时，朋友圈好多朋友也在发文章感慨这一年的经历。嗯，也确实是这样，又过了一年了。 工作方面前几天公司要求写年终总结，这一年大大小小的项目加起来居然也做了大概40多个项目，有些项目代码码的飞快，有些则抓耳挠腮、经历痛苦。 生活方面依旧在追寻美好的道路上前行，虽结果不尽人意，但至少尝试努力过了，也没什么遗憾，很多时候其实也很清楚明白，理想和现实终归是有差距的。依旧是独来独往屌丝一个，无法改变旁人，旁人也无法改变我~ 爱好方面后半年喜欢上了看动漫，斗罗大陆、魔道祖师、星辰变…也不得不在感慨，现今国产动漫确实拍的越来越好了，画风剧情确实都值得点赞。这一年在影院看了5~6部影片，推荐《我不是药神》、《无名之辈》、《无双》，国产良心剧、影片结束久久不愿离场，非要等到片尾曲都播放完。 技能方面经验多了，自然有了很多处理问题的方式，不再那般手足无措，也在学习新技术的方向上努力着~不过依旧浪费了很多时光，对这个社会焦虑着、彷徨着，但又步履蹒跚的不断往前走着… 旅行方面居住的这座城市逛了不少小众景点，去了两趟魔都，外出旅行总是可以给自己独立思考的时机，想很多日常不愿去想的琐事。 新年愿望继续努力前行，完成个人既定目标，新的一年会好么？嗯，一定会的吧！]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网站备案]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%85%B3%E4%BA%8E%E7%BD%91%E7%AB%99%E5%A4%87%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一个月的月底，到了发博文的时间。写博客文章本应成为一个习惯，现在成为一个月一篇，变得越来越懒，伸个手都觉得累~ 估计是天冷了吧~ 今日想谈谈域名认证与网站审核，上月底突发奇想，想搞一个自己的网站，比较“正规”的网站，有对外域名和自己的服务器，包括网站的审核，于是乎便开始了捣鼓的旅程… 域名认证域名认证没什么好谈的，在域名购买完之后，在域名购买商实名认证就可，本人在阿里购买的域名，认证都很快，很方便。 网站解析网站解析即将自己购买的域名与服务器IP绑定起来，DNS域名解析，将你的域名指向对应的服务器IP，由于本人域名在阿里购买，服务器为腾讯云，故而在解析的时候可能会有修改DNS域名解析服务商的提醒，按照操作执行即可。 网站备案审核走的是个人网站审核流程，在腾讯云后台备案系统中填入相关的备案信息，因为是个人网站，故而需要填写个人相关信息。这一流程主要是腾讯云那边采集的信息。 值得一提的是，其中有一步是需要将网站备案申请打印出来，个人签名然后拍照上传，如果拍照不清晰，会被打回来重新提交； 另外需注意，在备案期间，网站是需要关闭的，不能对外访问。所以，在近一个月的备案时间中，服务器一直处于关闭状态，并且删除了DNS域名解析信息。 next腾讯云会有一个幕布拍照审核的流程，腾讯云那边会给你寄一个幕布，站在前边拍张照片，上传即可 next腾讯云审核通过之后会提交给当地交管局审核，这一流程比较长，毕竟政府部门，工作日才会审核 本人网站备案耗时近一个月，还算顺利，基本上按要求填写即可，备案完成后会有一个备案号，可以在交管局官方网站查询到你的网站相关信息 域名ssl证书生成(支持https访问)网站备案完成，开启网站服务，支持域名访问，突然发现不是https开头，浏览器会提示不安全网站，需要在域名注册商出生成ssl证书，并绑定到对应服务器上，即绑定到apache等相关服务，具体参考相关服务绑定流程]]></content>
      <tags>
        <tag>备案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于小程序wxml页面处理js逻辑]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%85%B3%E4%BA%8E%E5%B0%8F%E7%A8%8B%E5%BA%8Fwxml%E9%A1%B5%E9%9D%A2%E5%A4%84%E7%90%86js%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[这一年又只剩了3个月左右，匆匆而逝。在和朋友聊天时也在谈论，这一年做了些什么？想想好像我的记忆都是跟着项目的版本号了，每个月至少一个版本的更新，从年初到现今，不知不觉，已经做了整整九个版本的小程序项目。从最初版本的几个简陋页面，到如今60多个页面的大小，几乎把网站核心功能都已经过了一遍，有的版本折磨的要死，有的版本飞快上线。 对比前端正常开发和小程序开发，小程序有优势也有劣势，最大优势便是基于微信这个平台做开发，分享，插件兼容什么的几乎可以不用去考虑，几乎所有常用的业务公用模块都提供了相应的API，“上拉刷新、下拉加载、轮播、弹窗封装，日期组件、不同状态的加载效果处理等等”，诸如写个swiper轮播，在小程序内部可能10分钟搞定，包括点击展示图片弹层，基础样式处理，而且你压根不需要考虑滑动问题。而如果想要在wap端实现这个功能，我可能需要先找一个swiper插件，引用一堆css/js文件，然后函数调用，完了还需要再单独考虑这个图片弹层该怎么实现？因为swiper好像还不能直接把它写出来，就这样，一小时过去了。。。领导拿着狼牙棒在你旁边直勾勾盯着你看。而在我看来它的劣势也便是它的优势，所有的东西都封装好，没法做个性化开发。 好了，言归正传，在之前八个版本的小程序开发时都或多或少遇到一个问题，页面中没法处理一些深入的业务逻辑，比如取整、时间戳转换日期、返回对象的JSON.parse处理，但是小程序页面wxml没有提供的一些方法。 先聊聊之前的处理方式，诸如处理时间戳：（不推荐） 外部引入时间日期处理公用JS12&lt;!-- xx.js --&gt;//时间日期处理方法（不详述） 当前页面JS文件1234567891011121314151617181920fetchData()&#123; wx.request(&#123; url:&apos;/ajax/test.json&apos;, data:&#123; &#125;, method: &apos;GET&apos;, success:function(res)&#123; if(res.data.message == &apos;success&apos;)&#123; let resList = res.data.resList; for(let i in resList)&#123; resList[i].createTime = time.format(resList[i].createTime) &#125; temp.setData(&#123; resList: resList &#125;) &#125; &#125; &#125;)&#125; 这样处理其实问题很突出，需要在每次返回代码中额外加入一段遍历的操作，浪费性能，而且代码没法复用，下一个页面如果再遇到这样的问题，还需要重新再处理一番。 小程序官方也对类似的问题提供了解决方案，只怪自己眼瞎，没看到。直到某一日看到一篇文章，才恍然大悟。 开发目录中可以创建.wxs后缀的文件，WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 wxs基础概念12345678&lt;!--wxml--&gt;&lt;wxs module=&quot;m1&quot;&gt;var msg = &quot;hello world&quot;;module.exports.message = msg;&lt;/wxs&gt;&lt;view&gt; &#123;&#123;m1.message&#125;&#125; &lt;/view&gt; 数据处理123456// page.jsPage(&#123; data: &#123; array: [1, 2, 3, 4, 5, 1, 2, 3, 4] &#125;&#125;) wxml中添加.wxs逻辑 1234567891011121314151617&lt;!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --&gt;&lt;wxs module=&quot;m1&quot;&gt;var getMax = function(array) &#123; var max = undefined; for (var i = 0; i &lt; array.length; ++i) &#123; max = max === undefined ? array[i] : (max &gt;= array[i] ? max : array[i]); &#125; return max;&#125;module.exports.getMax = getMax;&lt;/wxs&gt;&lt;!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --&gt;&lt;view&gt; &#123;&#123;m1.getMax(array)&#125;&#125; &lt;/view&gt; wxml中引入.wxs文件 12345678var filters = &#123; toFix: function (value) &#123; return value.toFixed(1) //此处1为保留一位小数 &#125;&#125;module.exports = &#123; toFix: filters.toFix&#125; 123&lt;wxs module=&quot;filters&quot; src=&quot;../tools.wxs&quot;&gt;&lt;/wxs&gt;&lt;view class=&quot;box&quot;&gt;&#123;&#123;filters.toFix(item.value)&#125;&#125;&lt;/view&gt; OK，完美解决！再也不用去写重复的一堆恶心代码… 红点规则为 tabBar 某一项的右上角添加文本1234wx.setTabBarBadge(&#123; index: 0, text: &apos;1&apos;&#125;) 移除taBar数量显示 123456789101112wx.removeTabBarBadge(&#123; index: 1, success:function()&#123; &#125;, fail:function()&#123; &#125;, complete:function()&#123; &#125;&#125;) 红点处理思路：在列表页访问时，将该列表最大ID记录下来，保存到缓存中。在小程序启动时，app.js中的onLaunch函数，走一遍列表接口，获取到列表的最大ID，通过ID数值差来判断用户有多少条数据未读，从而展示到对应的tabBar上，列表更新后，把该消息移除。 scroll-view无法横向滚动问题搞了快半小时，结果发现是scroll-view少加一个css属性，导致无法滑动。。。on shit~ 123.scroll-content&#123; white-space: nowrap;&#125; 数据未加载完成不展示页面结构1234567891011wxml:&lt;view class=&quot;container&quot; hidden=&quot;&#123;&#123;!loading&#125;&#125;&quot;&gt;&lt;loading hidden=&quot;&#123;&#123;loading&#125;&#125;&quot;&gt;加载中...&lt;/loading&gt;JS:Page(&#123; data:&#123; loading: true &#125;&#125;)]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序字母导航]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[小程序字母导航wxml: scroll-into-view 滚动到页面中对应ID的位置123456789101112&lt;scroll-view style=&quot;height:&#123;&#123;windowHeight&#125;&#125;;&quot; scroll-into-view=&quot;&#123;&#123;alpha&#125;&#125;&quot;&gt; &lt;view class=&quot;item&quot; wx:for=&quot;&#123;&#123;keymap&#125;&#125;&quot; id=&quot;&#123;&#123;item&#125;&#125;&quot;&gt; &lt;/view&gt;&lt;/scroll-view&gt;//字母表位置(catchtouchstart, catchtouchmove, catchtouchend 分别为滑动事件开始、移动和结束)&lt;view data-id=&quot;selector&quot; catchtouchstart=&quot;handlerAlphaTap&quot; catchtouchmove=&quot;handlerMove&quot; catchtouchend=&quot;handlerEnd&quot; class=&quot;alphanet-selector&quot;&gt; &lt;view data-ap=&quot;&#123;&#123;item&#125;&#125;&quot; wx:for=&quot;&#123;&#123;keymap&#125;&#125;&quot; wx:key=&quot;unique&quot; class=&quot;selector-one&quot; wx:for-item=&quot;item&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;&lt;/view&gt; JS： 1234567891011121314151617181920212223242526272829303132333435363738394041//滑动开始handlerAlphaTap(e) &#123; let &#123; ap &#125; = e.target.dataset; this.setData(&#123; alpha: ap, touchStatus: true &#125;);&#125;,//滑动过程handlerMove(e) &#123; if(this.data.touchStatus)&#123; if(this.timer)&#123; clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; let &#123; keymap &#125; = this.data; let moveY = e.touches[0].clientY; let rY = moveY - this.offsetTop; if (rY &gt;= 0) &#123; let index = Math.floor((rY - this.apHeight) / this.apHeight); if (0 &lt;= index &amp;&amp; index &lt; keymap.length) &#123; let nonwAp = keymap[index]; wx.showToast(&#123; title:&apos;&apos;+ nonwAp +&apos;&apos;, icon:&apos;none&apos;, duration: 500 &#125;) nonwAp &amp;&amp; this.setData(&#123; alpha: nonwAp &#125;); &#125; &#125; &#125;,16) &#125;&#125;,//滑动结束handlerEnd() &#123; this.setData(&#123; touchStatus: false &#125;)&#125; 小程序自定义多选功能js:123456789101112131415161718moreSelect()&#123; let resultmap = this.data.resultmap; //为数组添加自定义属性 for(let i in resultmap)&#123; resultmap[i][&apos;select&apos;] = false; &#125; this.setData(&#123; resultmap: resultmap &#125;)&#125;,selectItem(e)&#123; let id = e.target.id; this.data.resultmap[id].select = !this.data.resultmap[id].select; this.setData(&#123; resultmap: this.data.resultmap &#125;)&#125; 推荐博客 莫昭的博客当事情来的时候，总会有应对之法的，仿佛并没有别人眼里看的那么坚韧、那么伟大。我们并没办法让命运停下来啊，除了冷静下来，寻求解决之法，其他的都没用。 人生已经那么艰难了，总是要有些甜蜜之处的。 一颗摇摆不定的芦苇，风吹过、季节淌过。凤永恒的吹，水比芦苇永恒的多，万事万物都没有留下痕迹。]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时光]]></title>
    <url>%2F2018%2F08%2F05%2Froad%2F</url>
    <content type="text"><![CDATA[走在陌生街头，怅然若失，不知道要去哪儿，也不知道在哪儿，总之，是一个陌生环境，就如以往一般，不知不觉来到一个陌生环境。 最近总担心自己失去什么，但好像本身就一无所有，或者拥有的本是自己臆想，其实原本并不属于自己。 路看似很近，实则很远。。。 吃着烤肠，炸鸡，呆呆地看着来来往往的行人，嗯，明日该上班了…… 时光匆匆而过，一年已经过了大半，看到GitHub满满当当的绿色，自己安慰自己，觉得好像做了些什么…但其实又什么都没做，works项目提交了300多次，douban-vue、travel项目构建了很长时间，但是好像依旧没什么进展，至今还被仍在那儿，快长了毛… 想一想目前除了公司项目还有什么项目能够拿得出手？好像又都没到自己内心的目标，恩，路漫漫，终归要一步一步踱向终点。 近来github访问速度越来越慢，因而备份了一份代码放到了Gitee（码云）上，如果加载较慢，可以选择打开 https://gwemz.gitee.io]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6个残酷的人生事实]]></title>
    <url>%2F2018%2F07%2F03%2F6%E4%B8%AA%E6%AE%8B%E9%85%B7%E7%9A%84%E4%BA%BA%E7%94%9F%E4%BA%8B%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[如果你的职业道路非常顺利，你的生活美满感情顺利，你可以不用读这篇文章。祝你一天愉快，这篇文章不是为你写的。你做的非常出色，我们都为你自豪。 对于其余的人来说，我希望你做一件事情：说出5件你引以为豪的事情。写在纸上也好，或者喊出来也好都可以。但这里有一个条件：你不可以列出你“是”怎样的人（比如，我是一个温柔的人，我很诚实），只能列出你“做”的事情（比如，我刚获得了全国象棋冠军，我做的chili是全麻省最好的）。如果你发现很难列出五件事情，这篇文章就是为你所写的。而且你他x娘de肯定一边听一边心里会不舒服。我的感受是，如果有人在1995年的时候跟我讲这些事情就好了。 第6个事实：这个世界只关心你能给予什么我们假设一下你最爱的亲人在大街上被枪击了。TA一边失血一边尖叫。一个路人冲上来说“让一下”。他仔细检查了伤口并拿出一把小刀准备在大街上动手术取出子弹。 你问他：“你是医生吗？”他回答说：“不是”你说：“你知道你要做什么，对吧？你是不是退伍的军医，还是……” 这个时候那个路人感觉有点不快了。他告诉你说他是一个好人，是一个诚实的人，他上班从来不迟到。他告诉你说他是一个孝顺的儿子。业余生活丰富，生活非常富足。他还说他从不说脏话。 你有点疑惑，说：“这ta吗的和我亲人被枪击躺在马路上有什么关系？我需要一个可以在伤口上动手术的人！你到底能不能做？” 现在这个路人非常生气了——为什么你就那么自私肤浅呢？你难道不在乎他的那些优良品德么？他刚才不对你说他总是记住女友的生日吗？他有那么多优良品质，你为什么就抓着他会不会外科手术这个事实不放呢？ 在那个疯狂的情形下，你会用你沾满鲜血的双手用力摇晃他的肩膀，大喊道：“废话！你说的那些优良品质都是屁话，因为在当前情况下我只需要一个可以止血动手术的人！你这个神经病给我滚！” 所以，这就是我要说的第一点成人世界的残酷事实：你其实天天都身处于上述的“当前情况”之中。只不过换作你是那个喋喋不休的好心路人，而社会上其他所有人都换作成那个流血的伤者。 如果你想知道为什么社会对你不屑，或者你为什么从不受到尊重，这是因为社会充满了 需要某样东西的人。他们需要人来造房子，他们需要食物，他们需要娱乐，他们需要人来满足性欲。你从出生开始就进入了这样的需要解决人们需求的社会系统。 你要么选择学习某种技能担当某样角色满足他人的需要，要么就选择被社会抛弃。这个社会不在乎你有多么善良，礼貌，无私。你会变穷，你会没有朋友，你会被遗弃。但这是不是说我们要刻版、自私呢？爱和温柔重要吗？当然了，但前提是这些爱是别人需要的，也是从其他人那里得不到的。 否则的话…… 第5个事实：别去相信嬉皮士的话 (Hippies are wrong)【原文此处引用了一段视频： http://v.youku.com/v_show/id_XNTIwNzE5MDg0.html ，到优酷搜索 ‘Glengarry Glen Ross speech’ 直达，英文对白： http://yu.ac.kr/~bwlee/esc/baldwin.htm 】 对于那些无法看视频的读者，这是一段著名的影院神片Glengarry Glenn Ross里Alec Baldwin的演讲。Baldwin的角色——你会假设是反角——对一屋子的销售员疯狂施压，警告他们说他们都会被解雇，除非他们可以搞定他们手上的单子。 “好人？关我屁事！慈父？去你ma的！回你的家和你孩子玩去！如果你想在这里工作，给我敲定手上的单子” 非常残酷、粗鲁、甚至有点疯狂。可是，这恰恰是这个社会对你期望的最诚实的写照。不同的是，在现实世界里，人们认为那样讲话太粗鲁了对你不礼貌，于是他们干脆什么都不说眼看着你失败。 这个电影片段改变我的人生。我如果知道怎么做的话，会把它录成闹钟每天早上叫我起床。Baldwin因此还拿了奥斯卡奖，而这个片段是他整个电影唯一出场的场景！正如前人已经分析过，这段演讲精彩之处在于，一般的人会理解为“天哪，我要有这么一个混蛋老板会怎样啊？”。而另一半人却会想“太ta嘛励志了！我现在就想去上班做业务去！” 或者，有一个心理学家写道：“如果当时你在那个房间里，你们中的一些人会明白这是工作，会从那段演讲里吸收能量，就像一个球队教练冲你大骂一样。你会觉得‘这家伙太有能耐了’。而另一些人会非常介意，认为这个老板是混蛋，你没有权利跟我这样说话。”以上节选自一篇对于“hipster（这个词很难翻译，姑且翻译为非主流潮人）”的批判文章。文章解释了这些人为什么会难找工作，并指出上述两种不同的态度——受刺激vs受激励——很大程度上决定你是否在现实生活中能成功。 比如说，有人会引用搏击俱乐部里的经典台词“You are not your job”。但事实上，你完完全全就是你的job（职责）。当然了，你的职责和你为公司的服务不是一回事请，但其实你只不过是你所有有用技能经验的综合体罢了。技能是某一个个体能为社会中其他人提供的有用服务。但别搞错了，你的“职责”——你为他人提供的有用服务——就是你的全部。 这就是为什么外科医生比喜剧作家更受到尊重。也是为什么机修工比无业潮人更受到尊重。如果你的死讯能登上新闻，这说明你的工作已经成为了你的标签。搏击俱乐部里Tyler说You are not your job，但他同时又操办了一家成功的肥皂公司同时成为了社会运动的领导人。He was totally his job （这句不翻译比较好理解）。 我们再这样理解一下：你还记得Chick-fil-A餐厅反对同性恋婚姻么？不论嬉皮们如何抗议，公司还不是照样卖出了成千上万的汉堡？这不是说顾客们认可他们，而是因为他们成功地完成了履行了他们的职责——做好吃的汉堡。这一点才是最关键的。 你不一定非要从心里喜欢这个事实。我也不喜欢我生日的时候天下雨。但天还是要下雨。人们有需求，人们会认可能够满足他们需求的人。世界就是通过这么简单的机制运行的，谁也改变不了。 如果你抗议说，我不是肤浅的物质主义者，金钱不是万能的，我只能说：我有说过金钱吗？说明你没看懂我的要点。 第4个事实：你所做的事情不一定要换成钱，但一定要有益于他人那么我们换一个非金钱的例子好了。这个网站(cracked.com)主要面向20出头的男性。我每天都要从邮箱里收到一大堆挫男抱怨女人不愿意接近他们，虽然他们是世界上最nice的男人。我可以解释他们的思路有什么问题，不过最好是让Alec Baldwin解释最好。 （译注：此处再次引用上述视频，我真的建议大家去看那个片段！） 在我们说的例子里，Baldwin就是你生活里那个女神。他们当然不会像Baldwin的角色那样粗鲁直接——社会教育我们不要对别人那么“诚实”——但问题是一样的：“你是好人？关我屁事！想在这里工作，就给我搞定工作。” 所以，你有什么感想呢？你对在书店里遇到的女神每天白日梦YY，为她午餐不吃色拉感到惋惜。她10年后会成为一个外科医生，你呢？ “什么？你是说除非我找到一个好工作赚大钱否则不可能把到女神？” 不！你的大脑跳跃太快了，因此你可以给自己一个理由认为所有拒绝你的女神都是肤浅自私的。我在这里就问一个问题：你给予了什么？你聪明么？幽默吗？情趣吗？天才？雄心？创意？好，那你做什么事情能向这个世界证明自己的优点呢？不要跟我说你是个好人——这是最起码的。你的女神每天有三打的男人对她“好”。用我们上文的例子来说，伤者在大街上流血，你到底会不会开刀？ “我不歧视女人，不歧视种族，不贪婪，不肤浅，也不虐待人！我和那些diao不垃几的男人不一样。”很抱歉，如果你所能做的事情只不过是你“没有”一堆缺点，就ta吗的给我从伤者身边滚出去！我们有的是风趣、英俊、事业成功的男人来帮助你的女神。 伤到你自尊了么？有一点？那现在怎样呢？你想碎碎念呢，还是打算学习怎么去做手术治疗那个伤者？取决于你。但你不要去抱怨为什么女神就喜欢找你口中的坏男人。她们吃这套是因为那些diao不拉几的男人有其他东西可以满足你的女神。“但我是一个聆听者！”是吗？你可以坐在女神身边几个小时听她念叨？你猜怎么着？角落里还有另一个男人可以这样做，他还是吉他高手！你如果不停地说你是一个好人，就像一个餐厅说他们的卖点是他们的食物不会让你拉肚子一样，就像一部电影的标题是“This Movie is in English”。 这就是为什么你可以做一个好人但仍然觉得自己是loser。 第3个事实：你恨自己是因为你无所作为“所以你的意思是要我去买一本教我如何把妹的书么？”当然不是，除非那本书的第一章是“让自己变成女孩子愿意接近的人”。因为这一步总是容易被忽略——人们总是问“我怎么能找到工作？”而不是“我如何成为雇主愿意雇用的人？”；人们总是问“怎么让女孩喜欢我？”而不是“我怎么成为女孩喜欢的人？”。对吧？因为后者往往要求你放弃自己喜欢的爱好，注重外表，天知道还要做其他什么牺牲。你甚至还可能要改变你的天性。 “但是为什么我不能就去找一个喜欢原本的我的人呢？”答案很简单：人是有需求的。别忘记我们的例子：伤者在流血，而你所做的只是抱怨找不到会自动愈合的伤口？ 【此处插入一段Youtube上点击率很高的猥琐街头艺人表演的视频】 每个人看了上面这段视频都会会心一笑。你能为人们带来笑声么？为什么不呢？是为什么阻止你穿上猥琐的衣服在街头边唱边甩鸡鸡呢？那家伙似乎知道赢得掌声的门道……做怪事……总比什么都不做好…… “但是我什么都不擅长！”我有好消息告诉你：如果你尝试反复练习做一件事情，任何事情，你都可以擅长此事。我小时候可能是全世界最糟糕的作者。到了25岁的时候稍微好那么一点点。但当我职场失意的时候，我用业余时间写作长达八年，一周写一篇文章，直到它为我换回了钞票。我花了13年时间才能登上纽约时报畅销书榜单。我大概花了20000个小时才慢慢磨快了我拙劣的文笔。 不希望花那么多时间磨练一门技术？那么我有好消息和坏消息告诉你。好消息是漫长的磨练可以让你慢慢走出困境——我忍受了多年琐碎的办公室工作，因为我知道我同时在学习一门技能。人们半途而废是因为要看到结果实在是太漫长了，同时也是因为他们没有意识到“结果”就是过程本身。坏消息是你别无选择。“想继续在这里工作？给我搞定手里的单子” 从我个人角度出发看，你并不是因为缺乏自信而恨自己，或者是因为别人羞辱你。你恨自己是因为你【什么都不做】。连你自己都不能爱“原本的自我”——这就是为什么你很可悲，不断写私信问我如何处理你的生活问题。 自己扳手指算一下：你有多少时间是在消费别人创造的东西（电视，音乐，电玩，网站）而不是生产你自己的东西？只有你的“产出”才能为你添加作为人的价值。 如果你听到这里听不下去了，并且用你从小听到大的陈词滥调回应说：“人的内在才是最重要的”，那么我只能说……（接下文） 第2个事实：你的内在只有通过所做的事情才能表现出来在我所从事的行业里，我认识无数有理想的作家。他们认为自己是作家，他们在聚会上介绍自己是作家，他们拥有一颗作家的热心。他们只缺乏最后的一步：写点ta吗的像样的东西出来。 是吗？难道“写点东西”就是真正决定谁是谁不是真正“作家”的标准吗？我的天哪，当然是了！ 这恰恰是对我以上所说一切最常见的反驳，也是对你生活中批评声音最常见的反驳。这是你不断对你自己暗示以逃避能帮你改善自我的刻苦工作的理由。“我知道我的内在是一个很好的人”。你也会听到人说“我做我自己”。 不要误会我的意思：你的内在非常重要。一个男人如果为了他的家庭从无到有造出一栋房子完全是因为他的内在是一个好人。你所做的一切坏事最初是一个坏的念头，萦绕在你脑中，直到最后实施。同样，做一件好的事情也是一样道理——内在的自我是你成功果实赖以生长的土壤。 但是所有人都应该知道，所有人却都不能接受的事实是：“没有最后的果实，你就什么都不是” 比如你内心非常同情穷人。很伟大。这会让你最后做什么实事么？你听到你社区里一些悲剧发生后，你会说“这些不幸的孩子啊，让他们知道我在内心同情他们”吗？你要这么说我就只好说法克you——给我去真正帮助他们才是真的。数以千万的人看了那段Kony视频（译注：2012年Youtube上很有争议的关于非洲儿童的视频），所有看过的人都“在心里同情他们”。那么这么强大的同情给儿童们带来了什么呢？屁都没有！每天有非洲的儿童死于非命，因为数以百万的我们对自己说关心和行动一样重要。这是我们内心的一种心理机制，控制着我们大脑里犯懒的那一部分，让我们不断逃避真正去做实事。 有多少人此刻正在想：“她（他）如果知道我是多么有趣的人，一定会爱上我。”真的吗？你那些有趣的想法有多少让世人知道了呢？如果你的心上人有一个隐藏摄像机跟着你拍一个月，他们会被录影的内容打动吗？记住，人们不会读心术，他们只会观察你的行动。 我希望你做的，只不过是用你看别人的标准来看你自己罢了。你有没有一个烦人的基督徒朋友给别人最大的帮助只不过是“我为你祈祷”？你觉得烦不烦？我这里还没涉及到祈祷是不是实际有用呢，他们提供的帮助不需要他们屁股离开沙发就可以做。他们认为自己思想纯净，但是他们纯净的思想土壤有没有结出果实呢？他们自己应该比别人更清楚这点——因为我“土壤-果实”的比喻就是从圣经里拿来的。圣经里耶稣曾经不止一次说过“人们是根据果实来评判一颗树的”。当然，耶稣从来不会说“想继续留在这里工作，就给我搞定单子”，但他说“凡不结好果实的树，都要砍下來，扔在火里。” 对以上这些话无动于衷的人，就如同电影里对Baldwin无动于衷的业务员一样。 第1个事实： 人的内心其实一直在拒斥进步人类的大脑是很神奇的。但你会发现大脑在拒斥进步的时候运转得比做实事的时候还快。你的意识会通过层层防御机制来排斥任何会让你改变现状的事情——问一下对任何事物有瘾头的人就知道了。 所以，到现在，你们中的许多人一边读这篇文章，一边会感觉到大脑在不断提供排斥这篇文章的理由。从经验上说，这些想法通常是： 有意将任何批评理解为侮辱“他凭什么说我又懒又没用？一个善良的人从来不会这样对我说话！作者写这些东西只不过是想显示自己有多么优越，让我这个loser对自己生活不满罢了！等我回复更损人的话给你！” 对人不对事“这人有什么资格告诉我怎么活？他自以为自己了不起吧？不过是网上的一个白痴写手罢了！我要去人肉他，看他有什么丑事可以抖出来。这人真自以为是，让我作呕” 只看语气，不看内容“我会仔细看你的文章，找出一句话，断章取义只讨论那个。” 不断修饰你的过去“事情没那么糟糕。确实我上个月还想自杀呢，但现在我感觉好多了！也许我只要继续做我现在做的事情，情况会好的。让我继续给那个女神修电脑，女神总会到我身边的！” 认为改善生活的行为总会让你失去自我“哦，那么你是让我扔掉所有的漫画书。天天去健身房6小时？因为除此之外我没选择了？” 当然还有其他的想法。记住： 痛苦是会让人感到舒坦的。许多人选择拥抱痛苦。幸福是需要努力的。 还有：勇气。人们无法批评你根本没有去创造出来的东西，所以人们选择什么都不做来避免批评。人们很容易双手一叉裤袋批评别人的工作。这个电影很傻，这对父母的小孩很皮，那对情侣的感情很糟糕，那个暴发户不学无术，这个餐厅糟透了，本文作者是个白痴，我倒不如留一条损的回复让网站开除他，瞧，我这不“创造”了一些东西么？ 哦，是啊，我忘记提醒你了。不论你尝试建造或者创造什么东西——诗歌也好，新的技术也好，或者新的感情也好——你会立刻发现自己身边多了很多批评家。这些批评家也许不会当你面损你，但是他们确实在挖苦你。你的酒鬼朋友不希望你清醒，你肥胖的朋友不希望你苗条，你无业的朋友不希望看到你开始新的职业。 记住，他们不过在表达他们对生活的恐惧罢了，批评别人的工作是自己不作为的另一个理由。“为什么我要创造什么东西呢，你看别人做的东西都糟透了！”“我想写小说，不过我要等时机，我可不想写出暮光那样肤浅的东西”。只要他们永远不动手去做事情，事情就永远是完美的。或者他们如果真的着手做事情了，他们会故意不努力，让别人认为事情做不好是因为他们不在状态，“他们真正的潜力是无穷的”，不是你看到的狗屎一样的产品。 往下翻读一下本文的回复——那些很极端的回复，永远都是“Cracked应该炒了这个作者”“这个自负的白痴应该停止写作”。所有一切的负面评论潜台词永远都是“停止创作，如果换我来创作绝对比这个好千倍，你现在得到那么多人气让我自己很没面子。” 不要成为上述的那种人。如果你是那种人，请不要继续成为那样的人。这正是人们为什么不喜欢你的原因，这正是你恨自己的原因。 所以，我有个建议：给自己定一个期限，2013年底，或者从你读本文之后的一年。当别人跟你说“我的新年计划是减肥15磅”的时候，我说咱们应该努力去做任何一件事情——学习新的技能直到足够有用为止，或者随便选一件事情：学空手道，学跳舞，学陶艺，做一个鸟屋，学习按摩，学一门语言，甚至拍一部A pian，做蝙蝠侠打击犯罪…… 关键在于：我不希望你把眼光放在某个过高的目标上，我希望你专注于获得一样新的， 对其他人有用的技能和经验。 “我没钱参加烹饪班”，那就ta吗的给我Google“如何烹饪”。我的天，拜托你戒掉这些借口，否则这些借口就要你命了。（You have to kill those excuses, or they will kill you）]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发总结]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[本文涉及的内容有：下拉刷新/上拉加载/检测滚动条滚动/三级品牌选择/微信授权登录/微信手机号授权登录/发送模板消息/微信支付/js复用/本地存储数组/刷新当前页面 and some problems 下拉刷新方式一 12345678910111213141516app.json(全局)&quot;window&quot;:&#123; &quot;enablePullDownRefresh&quot;: true&#125;page.json(当前页面)&#123; &quot;enablePullDownRefresh&quot;: true&#125;//下拉逻辑(Page)onPullDownRefresh:function(e)&#123;&#125; 方式二123&lt;scroll-view bindscrolltoupper=&quot;refresh&quot; bindscrolltolower=&quot;loadmore&quot; scroll-y=&quot;true&quot;&gt;&lt;/scroll-view&gt;bindscrolltoupper 滚动到顶部/左边 上拉加载方式一1234//滚动条到最底部执行(Page)onReachBottom:function()&#123;&#125; 方式二123&lt;scroll-view bindscrolltoupper=&quot;refresh&quot; bindscrolltolower=&quot;loadmore&quot; scroll-y=&quot;true&quot;&gt;&lt;/scroll-view&gt;bindscrolltolower 滚动到底部/右边 检测滚动条滚动123456789101112//检测滚动条滚动事件onPageScroll:function()&#123;&#125;//回到页面顶部gotop:function()&#123; wx.pageScrollTo(&#123; scrollTop: 0, duration: 400 &#125;);&#125; 关于三级品牌选择‘三级品牌’?’弹窗’:’单独页面’ 优点：单独页面(简化单个页面代码量、代码复用、用户体验) 不同页面数据通信 setStorage or setData setStorage12345678910111213141516171819单独页面js:wx.setStorageSync(&apos;onebrandid&apos;, pids);wx.setStorageSync(&apos;onebrand&apos;,brand);wx.setStorageSync(&apos;brandpic&apos;,pic);原页面:onShow:function()&#123; let cartype = wx.getStorageSync(&apos;onebrandid&apos;); let bigType = wx.getStorageSync(&apos;onebrand&apos;); let parSerial = wx.getStorageSync(&apos;brandpic&apos;);&#125;清除本地缓存带来影响delstorage: function () &#123; let arr = [&apos;onebrandid&apos;, &apos;onebrand&apos;, &apos;brandpic&apos;]; for (let i in arr) &#123; wx.removeStorageSync(arr[i]); &#125;&#125; setData123456789101112goBack:function()&#123; let pages = getCurrentPages();//当前页面 let prevPage = pages[pages.length - 2];//上一页面 prevPage.setData(&#123;//直接给上移页面赋值 onebrandid:price, onebrand:name, brandpic:id &#125;); wx.navigateBack(&#123; delta: 1 &#125;)&#125; 返回原页面1234// 跳回到选择页面(消除返回箭头带来的影响)wx.navigateBack(&#123; delta: 3&#125;) 微信授权登录1234567891011121314151617181920212223242526272829303132333435wxml:button open-type=&quot;getUserInfo&quot; plain=&quot;true&quot; bindgetuserinfo=&quot;bindGetUserInfo&quot;app.js -&gt; codejs:bindGetUserInfo:function()&#123; //用户同意授权 if (e.detail.errMsg == &apos;getUserInfo:ok&apos;)&#123; // 判断sessionKey是否失效(AppID + AppSecret) access_token -&gt; 用于获取用户唯一表示openid -&gt; 发送模板消息 wx.checkSession(&#123; success: function (res) &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.saveUserInfo(res.encryptedData, res.iv, code) &#125; &#125;) &#125;, fail: function () &#123; wx.login(&#123; success: function (res) &#123; let code = res.code; wx.getUserInfo(&#123; success: function (res) &#123; that.saveUserInfo(res.encryptedData, res.iv, code) &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125;&#125;//解密保存用户信息saveUserInfo:function()&#123;&#125; 微信授权手机号登录12345678910111213141516171819202122wxml:&lt;button open-type=&quot;getPhoneNumber&quot; bindgetphonenumber=&quot;getPhoneNumber&quot; plain=&quot;true&quot;&gt;js:getPhoneNumber:function()&#123; if (res.detail.errMsg == &apos;getPhoneNumber:ok&apos;) &#123; let encryptedData = res.detail.encryptedData; let iv = res.detail.iv; wx.login(&#123; success: function (res) &#123; // success let code = res.code; that.userphoneNum(encryptedData, iv, code) &#125; &#125;) &#125;&#125;//解密用户手机号userphoneNum:function()&#123;&#125; 发送模板消息前置条件（用户已完成授权操作）方式一(表单) 1234567891011//表单(用于生成fomId) 真机环境测试&lt;form report-submit=&quot;true&quot; class=&quot;right&quot; bindsubmit=&quot;formSubmit&quot;&gt; &lt;button bindtap=&quot;inquiry&quot; form-type=&quot;submit&quot; plain=&quot;true&quot;&gt;发送模板消息&lt;/button&gt;&lt;/form&gt;// 获取formIdformSubmit: function (e) &#123; let formid = e.detail.formId;&#125;//后台模板配置 方式二(prepay_id) 支付完成之后可发送 微信支付123456789101112131415161718192021222324252627282930313233343536373839// 登录获取codewx.login(&#123; success: function (res) &#123; var code = res.code; // 获取支付需要的参数 wx.request(&#123; url: weixinUrl, data: &#123; childtype: &apos;leixin&apos;, loginName: mobile, money: price, rechargetype: 1, code: code &#125;, method: &apos;GET&apos;, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT header: &#123; &apos;from&apos;: &apos;miniprogram&apos; &#125;, // 设置请求的 header success: function (res) &#123; // success var data = JSON.parse(res.data); // 支付步骤 wx.requestPayment(&#123; &apos;timeStamp&apos;: data.timeStamp, &apos;nonceStr&apos;: data.nonceStr, &apos;package&apos;: data.package, &apos;signType&apos;: data.signType, &apos;paySign&apos;: data.paySign, &apos;success&apos;: function (res) &#123; wx.showToast(&#123; title: &apos;支付成功&apos; &#125;) &#125; &#125;) &#125; &#125;) &#125;&#125;) 手机验证码登录1234567891011121314151617181920login.js:function aa()&#123;&#125;function bb()&#123;&#125;module.exports = &#123; A: aa, B: bb&#125;page.jsimport login from &apos;../../utils/login&apos;;/* 登录方法获取 */for (let key in login) &#123; temp[key] = login[key]&#125; 本地存储数组12345678数组、对象、字符串/*异步*/wx.setStorage(&#123; key:&quot;value&quot;, data:&quot;data&quot;&#125;)/*同步*/wx.setStorageSync(&apos;value&apos;,&apos;data&apos;); 刷新当前页面that.onShow() 在onshow函数中执行获取相关数据的操作 华为手机中文传参乱码部分设备中文传参乱码，导致无法获取正确数据，解决方法：encodeURI() 将字符串作为URI进行编码encodeURI(this.data.serial) problemsiphonex 适配授权登录不同版本微信表现不一致部分设备加载慢滑动体验问题]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史记·河渠书]]></title>
    <url>%2F2018%2F05%2F12%2F%E6%B2%B3%E6%B8%A0%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[《夏书》记载：禹治理洪水经历了十三年，其间路过家门口也不回家看望亲人。行陆路时乘车，水路乘船，泥路乘橇，山路坐轿，走遍了所有地方。从而划分了九州边界，随山势地形，疏浚了淤积的大河川，根据土地物产确定了赋税等级。使九州道路通畅，筑起了九州的泽岸，度量了九州山势。然而还有黄河泛滥成灾，给中国造成很大危害。于是集中力量治理黄河，引导河水自积石山经过龙门，南行到华阴县，东下经砥柱山和孟津、雒汭，到达大邳山。禹以为大邳以上黄河流经的地区地势高，水流湍急，难以在大邳以东的平地经过，否则会时常败堤破岸，造成水灾，于是将黄河分流成二条河以减小水势，并引水北行，从地势较高的冀州地区流过，经降水，到大陆泽，以下开九条大河， 共同迎受黄河之水，流入勃海。九州河川都已疏通，九州大泽都筑了障水堤岸，华夏诸国得到治理而安定，其功绩使夏、商、周三代受益不绝。 后人又自荥阳以下引河水东南流，成为鸿沟，把宋、郑、陈、蔡、曹、卫各国连结起来，分别与济、汝、淮、泗诸水系交会。在楚地，西方在汉水和云梦泽之间修渠连通，东方则在江淮之间用沟渠相连。在吴地于三江、五湖间开凿河渠。在齐则于菑、济二水间修渠。在蜀，有蜀守李冰凿开离堆，以避沫水造成的水灾；又在成都一带开凿二条江水支流。这些河渠水深都能行舟，有余 就用来灌溉农田，百姓获利不小。至于渠水所过地区，人们往往又开凿一些支渠引渠水灌田，数目之多不下千千万万，但工程小，不足数计。西门豹引漳水灌溉邺郡的农田，使魏国的河内地区富裕起来。 韩国听说秦国好兴办工役等新奇事，想以此消耗它的国力，使它无力对山东诸国用兵，于是命水利工匠郑国找机会游说(shuì，税)秦国，要它凿穿泾水，从中山(今陕西泾阳县北)以西到瓠(hù，户)口，修一条水渠，出北山向东流入洛水长三百余里，欲用来灌溉农田。渠未成，郑国的目的被发觉，秦国要杀他，郑国说：“臣开始是为韩国做奸细而来，但渠成以后确实对秦国有利。”秦国以为他说得对，最后命他继续把渠修成。渠成后，引淤积混浊的泾河水灌溉两岸低洼的盐碱地四万多顷，亩产都达到了六石四斗。从此关中沃野千里，再没有饥荒年成，秦国富强起来，最后并吞了诸侯各国，因把此渠命名为郑国渠。 汉朝建立后三十九年，到孝文帝时黄河堤决于酸枣县，向东冲溃金堤，于是东郡动员了许多兵卒堵塞决口。 此后过了四十多年，到本朝天子元光年间，黄河在瓠子决口，向东南流入钜野泽，将淮河、泗水连成一片。于是天子命汲黯、郑当时调发人夫、罪徒堵塞决口，往往堵塞以后又被冲坏。那时朝中的丞相是武安侯田蚡(fén，坟)，他的奉邑是鄃(shū，舒)县，以鄃县租税为食。而鄃县在黄河以北，黄河决口水向南流，鄃县没有水灾，收成很好。所以田蚡对皇帝说：“江河决口都是上天的事，不易用人力强加堵塞，即便将决口堵塞了，也未必符合天意。”此外望云气和以术数占卜的人也都这样说。因此天子很长时间没有提堵塞决口的事。 那时郑当时任大司农职，说道：“往常从关东漕运的粮食是沿渭水逆流而上，运到长安估计要用六个月，水路全程九百多里，途中还有许多难行的地方。若从长安开一条渠引渭水，沿南山而下，直到黄河才三百多里，是一条直道，容易行船，估计可使漕船三个月运到；而且沿渠农田一万多顷得到灌溉。这样既能减少漕省运粮的兵卒，节省开支，又能使关中农田更加肥沃，多打粮食。”天子认为说得对，命来自齐地的水利工匠徐伯表测地势，确定河道走向，动员全部兵卒数万人开凿漕渠，历时三年完工，通水后，用来漕运，果然十分便利。此后漕渠渐渐多起来，渠下的老百姓都颇能得到以水溉田的利益。 后来河东守番系说：“从山东漕运粮米西行入关，每年一百多万石，中间经过砥柱这个行船的禁限地区，有许多漕船船坏人亡，而且运费也太大。若穿渠引汾水灌溉皮氏、汾阴一带的土地，引黄河水灌溉汾阴、蒲坂一带的土地，估计可以造田五千顷。这五千顷田原来都是河边被遗弃的荒地，老百姓只在其中打草放牧，如今加以灌溉耕种，估计可得粮食二百万石以上。这些粮食沿渭水运入长安，与直接从关中收获的没有两样，而不再从砥柱以东漕粮入关。”天子同意他的意见，动员兵卒数万人造渠田。几年以后，黄河改道，渠无水，种渠田的连政府贷给的种子也难以偿还。久而久之，河东渠田完全报废，朝廷把它分给从越地内迁的百姓耕种，使少府能从中得到一点微薄的租赋收入。 以后有人上书，是为了想打通褒斜道以及漕运的事，天子交给御史大夫张汤，张汤详细了解后，说道：“从汉中入蜀向来走故道，故道有许多山坂大坡，曲折路远。今若凿穿褒斜道，山坂坡路少，比故道近四百里的路程；而且褒水与沔水相通，斜水与渭水相通，都能通行漕船。漕船从南阳沿沔水上行驶入褒水，从褒水登陆到斜水旱路一百多里，以车转运，再下船顺斜水下行驶入渭水。这样不但汉中的粮食可以运来，山东的粮食从沔水而上没有禁限，比经砥柱漕运方便。而且褒斜地区的木材箭竹，其富饶可以与巴蜀相比拟。”天子认为有道理，封张汤的儿子卬(áng，昂)为汉中郡太守，调发数万人开出一条长五百多里的褒斜道。果然方便而且路程近，但是水流湍(tuān)急多石，不能通漕。 此后庄熊罴说：“临晋地区的老百姓愿意凿穿洛水筑成水渠，用来灌溉重泉以东原有的一万多顷盐碱地。倘若果然能得水灌溉，可使每亩产量达到十石。”于是调发兵卒一万多人开渠，自徵城引洛水到商颜山下。由于土岸容易塌方，于是沿流凿井，最深有的达到四十多丈。许多地方都凿了井，井下相互连通，使水通行。水从地下穿商颜山而过，东行直到山岭之中十多里远。从此产生了井渠。凿渠时曾掘出了龙骨，所以给此渠命名为龙首渠。这条渠筑了十多年，颇有些地方通了水，但是并未得到太大的好处。 自从黄河在瓠子决口后二十多年，每年土地都因水涝没有好收成，梁楚地区更为严重。天子既已封禅，并巡祭了天下名山大川，第二年，天由于要晒干泰山封土而少雨。于是命汲仁、郭昌调发兵卒数万人堵塞瓠子决口，阻止水涝，天子从万里沙祠祷神以后，回来的路上亲临黄河决口处，沉白马、玉璧于河中祭奠河神，命群臣及随从官员自将军衔以下，都背负柴薪，填塞决口。当时东郡百姓以草为炊，柴薪很少，因而命砍伐淇园的竹子作为塞决口的楗。 天子既然亲临决河处，悼念塞河不能成功，作歌道：“瓠子河决啊有何办法，浩浩汗汗啊民居已尽为河。尽为河啊地方不安，河工无休止啊吾山已经凿平。吾山已平啊钜野泽外流，水族喧嚷啊迫天齐日。河道废弛啊水离常流，蛟龙驰骋啊正远游。水归旧道啊神福滂沛，若不封禅啊怎知此事！为我告河伯啊因何不仁，泛滥不止啊愁煞人。河浸齧(niè，聂)桑啊淮、泗水满，久不归故道啊唯愿水流稍缓。”另一首是：“河水汤汤(shāng，商)啊流急，北渡回曲啊疏浚难。揭草埽于决口啊沉美玉于河，河伯纵许息水啊奈薪柴不足。薪柴不足啊卫人获罪，民烧柴尚不足啊如何御水！伐淇园之竹啊楗阻石柱，堵塞宣房啊万福来。”于是塞住了瓠子决河，在决口处筑了一座宫殿，取名为宣房宫。并修二条渠引河水北行，恢复了禹时的样子，梁、楚地区重又得到安宁，没有水灾了。 从此以后，负责河渠事的官员争相建议修筑水利。朔方、西河、河西、酒泉等地都引黄河以及川谷中的水灌溉农田；而关中的辅渠、灵轵渠引诸川中的水；汝南、九江地区引淮河水；东海郡引钜定泽水；泰山周围地区引汶水。各自所开渠都能灌溉农田万余顷。其他小渠以及劈山通水道的，不可尽言。但工程最大的还是宣房治河的工程。 太史公说：“我曾南行登上庐山，观看禹疏导九江的遗迹，随后到会稽太湟，上姑苏台，眺望五湖；东行考察了洛汭(ruì，锐)、大邳，逆河而上，走过淮、泗、济、漯、洛诸水；西行瞻望了西蜀地区的岷山和离堆；北行自龙门走到朔方。深切感到：水与人的利害关系太大了！我随从皇帝参加了负薪塞宣房决口那件事，为皇帝所作《瓠子》诗感到悲伤，因而写下了《河渠书》。 中国水博——龙施雨沛]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shanghai tourist]]></title>
    <url>%2F2018%2F05%2F01%2Fshanghai-tourist%2F</url>
    <content type="text"><![CDATA[多图预警，流量党慎入三天两夜上海之旅匆匆而过，旅行总是美妙的，让你置身于一个场景中，放松身心，将日常工作的烦恼短暂抛开。 初到上海，感受最深的便是它庞大的地铁系统。感觉无论去什么地方，地铁都可以将你带到目的地，当然与之而来的是庞大的客流量，可以想象每日上班族忙忙碌碌挤地铁的身影。 上海地铁一张上海地铁图可以感受下。四通八达…… 世博园夜晚，世博园，但已关门，如果想去内部看的话可以早点去，不过夜晚可以看到黄浦江的夜景。观景台上，凉凉微风，迷人风光。 总有感觉当假期有时间了，但人也多了，五一看的更多不是风景，而是人潮……一年又一年，大家在抱怨五一假期人山人海时，同时也背起行囊，规划着自己的出行。而在我看来，旅行看景已不是那么重要，走过形形色色的不少地方，早已清楚，各地风景大多千篇一律，有特色的也就那么一两个独有地儿，大部分都包裹着严重的商业气息，在这儿可以看到的，别的地方也一样可以遇到。吸引我的可能更多是人与人的交流，三两好友，久别重逢，聊聊近况，谈谈明日，互联网将人与人的距离拉近了，但又拉远了，因为沟通方式太容易，反而我们不愿意去主动交流。 上海博物馆上海博物馆(排了一个多小时进去)，集各地文物精华于一身，但又有自身的良褚文化，正如上海的特性，包容，海纳百川。 南京路步行街南京路步行街，有意思的是感觉上海的每一条路，每一道街都能找到全国的对应地，比如天津路，四川路等等。 大上海的繁荣可能在这一条街有着更为直观的体现…… 上海外滩外滩，站在外滩，看着对岸的东方明珠，海上驶来驶去的船舶。 陈毅市长，上海第一任市长 上海东方明珠东方明珠电视塔，人人都想登上去在高处看看上海这座城，但人山人海，可能与我文艺范气息不太相符，拍了张合影，匆匆离去…… 世界金融中心，有钱人的世界我们想象不到。 士兵兄弟在烈日下坚守岗位的士兵兄弟，为你们点赞！ 老了，当年六小时爬华山的记录已不复存在，走几步路就喊累……遂早早乘车打道回府，迎接接下来新的挑战。 楞是把博客写成了游记，完。。。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发总结]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[近半个月在做微信小程序项目，记录一些开发过程中遇到的问题，做个记录。 微信小程序开发模式相比传统开发模式更加便捷，因为其封装了许多实用的api，开发过程中只需要按照他提供的框架进行开发，对于基本的业务需求都可以实现。 微信分享开发中需要做小程序分享功能，当然，它提供了API，比如你分享的bintap=”share”,则需要在share函数中执行分享代码值得一提的是，如果页面中有多个分享按钮，且分享的路径不同，可通过给分享按钮button添加不同的id，在js中对id进行区分，进而执行不同的分享代码 123456789101112131415161718192021222324252627282930313233share:function()&#123; Page.onShareAppMessage&#125;onShareAppMessage:function(res)&#123; //分享按钮一 if(res.target.id == &apos;0&apos;)&#123; return &#123; title:&apos;&apos;, path:&apos;&apos;, imageUrl:&apos;&apos;, success:function()&#123; &#125;, fail:function()&#123; &#125; &#125; &#125; &lt;!-- 分享选项二 --&gt; else&#123; return &#123; title:&apos;&apos;, path:&apos;&apos;, imageUrl:&apos;&apos;, success:function()&#123; &#125;, fail:function()&#123; &#125; &#125; &#125;&#125; 在分享功能中，有个需求，需要将详情页分享出来，正常情况按照提供的API完全可以实现，但是分享出来的详情页打开之后没有返回按钮，即无法返回到列表页，而要想分享的页面中出现返回键，一个思路便是将分享路径配置为列表页路径，后边添加详情页参数，在列表页中通过判断该参数，再让页面跳转至详情页，代码如下:1234567891011121314151617181920212223&lt;!-- 详情页分享 --&gt;onShareAppMessage:function()&#123; return &#123; title:&apos;详情页标题&apos;, path:&apos;/pages/list/list?id=123&apos;, imageUrl:&apos;&apos;, success:function()&#123; &#125;, fail:function()&#123; &#125; &#125;&#125;&lt;!-- 列表页处理 --&gt;onLoad:function(options)&#123; if(options.id)&#123; wx.navigateTo(&#123; url:&apos;../detail/detail?id=&apos;+options.id &#125;) &#125;&#125; 下拉加载做下来加载功能是，其实微信提供了非常方便的API，有两种处理方式， 方法一： ，在该组件中提供了bindscrolltolower这个方法，可以监听滚动条到底部时的变化， 方法二：通过onReachBottom方法，微信小程序在每一个页面Page下都配置了该方法，即滚动条滚动到最底部时便会执行，故而可以将下拉加载的业务逻辑写到该方法中，也是非常方便 123456loadmore:function()&#123;&#125;onReachBottom:function()&#123;&#125; 样式处理小程序项目开发，按照官方推荐的flex+rpx布局方式，由于flex布局方便属性，写样式很方便。单位选择通过rpx来做适配，即iphone6设计尺寸下，1px = 1rpx 图片处理比较大一些的背景图放到了公司服务器目录下，小一些icon图则放到了小程序的开发目录中，因为小程序对文件大小的要求是小于2M，故而较大的图片不建议放到开发目录中 组件化开发对于业务中公用的模块可以选择拆分为一个单独的组件，这样，日后在维护和复用方面都非常方便。 小程序审核这次审核从前一天下午到第二天中午审核便通过了，因为代码在上传编译后出了一些问题，便在后台管理系统中回退到之前的版本。 缺点微信小程序开发工具不太友好，同chrome相比，优劣势可见一斑。 小程序项目发布之前，都需要微信审核通过之后才可发布，这个过程往往比较耗时，虽然快点几个小时便可审核通过，但始终没有发布到自己的服务器上方面方便，如果项目出现bug，并不能及时修改发布。 总结小程序开发总体上来说还是很便捷的，前后端分离的开发模式，采用了类似于MVVM的框架进行数据渲染，flex布局+rpx适配，对大部分css属性的支持，真机调试也非常的快捷，提供了预览、远程调试两种方式，可以更加快速定位问题，唯一的问题便是，开发工具比较坑，和chrome控制台相比，真是。。。在这次开发中代码编辑没有自带的工具，而是选择了vscode，安装了插件vscode-wechat可以对微信小程序的一些语法进行支持，感兴趣的可以试试。 小程序开发中，官方提供了一个框架，wepy，看到github上活跃度也是非常高，可以试试，以及美团开源的mpvue框架，据说可以一份代码实现移动端、小程序两方面的功能，都可以研究研究，做个参考。 微信授权接口调整 微信手机号码授权登录发送模板消息支付凭证中添加打开小程序入口]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非凡匠心二]]></title>
    <url>%2F2018%2F04%2F06%2F%E9%9D%9E%E5%87%A1%E5%8C%A0%E5%BF%83%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[今日还是想谈谈匠心，由“非凡匠心”中《龙泉宝剑》一集得出的感悟。刚好，做的项目遇到了各种各样的问题（项目的进度远远超过了原先的预期，同时由于第一次做小程序的项目，遇到了一些不知所以然的问题，今日怕是又要耗些时间），索性谈谈关于这一集的感悟换换头脑。 这一期的嘉宾是有张国立、任贤齐前往浙江龙泉铸剑之地，拜访陈阿金师傅，一位铸剑铸了50多年的老师傅。文化传承人。 在铸剑的过程中，每一把剑都需要成百上千次的反复敲打锻造最终成型。铸剑的过程即便有丝毫的失误，也得重新再来…节目中张国立和任贤齐在第一次锻造过程中，因为一次小小的失误，铸剑的铁无法继续锻造，只能重头再来。而一个铸剑师，要想达到炉火纯青的锻造手艺，中间重头再来的经历又何止千百次？而要想把铸剑一门的手艺发扬光大，更离不开日积月累反复的研磨、试错，不断的调整、不断的重头再来。 忽的感觉，每个行业不都是这样么？就如同程序员行业，脑力行当，但同时又和铸剑又和区别呢？每一次的项目便等同于一次铸剑，于是我们便开始日复一日的敲代码实现功能，项目中又有许许多多的细节之处，就如同铸剑过程中的那每一个小小的研磨、花纹，铸剑需要打磨好多次，而做一个项目不也是需要不断的反复测试、修改么？那么如果一把剑已经打好了，在交付给剑客使用的时候，没怎么使用就断了，那么肯定第一想到的便是这个铸剑师不合格，不具有匠心。而我们在做一份项目，交付给很多人使用的过程中，发现体验不好，有很多的bug，那么用户首先想到的便是这个程序员不合格。 陈阿金师傅在锻造一把需要当成国礼送给普金的剑时，剑身上需要刻画一百多个寿字，用到了之前没有用的技术，同时这种大的场合不能有丝毫的差错。可想而知，陈阿金师傅在锻造的过程中有多么大的压力，锻造这一把剑花费了8个多月时间。中途肯定经过了数不清的重头再来。我想陪伴到最后的必然是每一次失败后重重的叹息与咬牙重头再来。在大谈匠心的时候，确实它又很平凡，很简单。无非是每一次失败后的再来以及对超越现有的执着。为何珍贵？因为能坚持下去的人并不多，但更多的时候我们不得不坚持。 再回到程序员这个行当，我们可能感觉，同别人相比，别人聪明、反应快，一天时间就做好了你需要两天才可以实现的功能，别人经验丰富，他对业务代码足够的熟悉、了解。但是，再聪明也离不开努力，否则必然会被淘汰。经验丰富的那位，相信以前也有当菜鸟的时候，也有为了赶项目没日没夜的加班熬夜。当你想到这儿，你就应该知道，其实每个人都一样，为了各种各样的目标，我们能够做的便是坚持，坚持脚下每一步路，坚持心中每一份坚持！]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江南铜屋]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%B1%9F%E5%8D%97%E9%93%9C%E5%B1%8B%2F</url>
    <content type="text"><![CDATA[非凡匠心第二季豆瓣影评8.9分，主要讲的是我们周边被我们所忽略的匠人匠心，尤其是在当今这个时代，当我们还在盲目推崇别国的精湛技艺的时候，殊不知，我们的周边一直有这样的一帮平凡人，他们有着非凡的匠心，一辈子将一件事做到了极致。 豆瓣影评中记得有这样一段话：“这是个浮躁的时代，每个人都这样议论。快节奏的生活，几乎压的人喘不过气来。吃着外卖，看着泛娱乐化的节目，干着有一天没一天的工作。人们在大谈特谈匠人精神的时候，可曾有一瞬间想过那些就活在自己身边那些活生生的例子。拐角炸了一辈子油条的王大爷，街口修了三十年自行车的喻叔叔，写了一辈子对联的李伯伯······” 其中有一期讲的是熔铜技艺，地点就在西子湖旁，河坊街江南铜屋。可能是因为三次经过，故而对这个地方印象深刻，在河坊街已变成一个商业化的街道时，江南铜屋倒是让我这样的人情有独钟。90后青年人，有着老年人的心态，对老物件情有独钟。突出表现在，每去一个城市，必然会先去当地的博物馆看看。看看这座城市的历史，将自己置身于那个时代，尤其是当看到水墨画或者是解放初期的照片时候，非常想穿越到那个时代，感受画中、照片中的情景。 江南铜屋的创始人是朱炳仁和朱军岷父子二人，朱家铜在历经五代人艰苦卓绝的创新、研磨之后终于在今日发扬光大，中国90%的铜建筑几乎都是出自朱炳仁先生设计并完成。节目中提起他本人最引以为豪的一件作品便是雷峰塔，因为其中包含了大量的铜造品。父子二人潜心研究，在常州天宁寺宝塔被焚而受感悟，创新了熔铜技艺，将铜造技艺在中国乃至世界发扬光大。 毋庸置疑，这是匠心的极致展现，将自己的事业坚持下去，并做到了极致。可能有人会说，因为我们从事的职业不同，在古老的行业可能更加能够展现匠心，就当今互联网的发展速度，在不远的将来你所从事的这个职业是否存在都是一个未知数？确实是这样，互联网的发展速度太快了，就从事的前端行业而言，几年之前，或许你会切页面、懂点jquery交互完全能够满足行业需求，但是到了如今，已远远不能够适应这个社会的需求。前端各大框架层出不穷，在我看来，现在的前端也可以说成是全栈，前端人员懂后台、懂框架已经成了标配。如果你还不知道这个现状，那么可能离淘汰也不远了。往往我们是被这个行业逼得不得不进步，领导随便打开一个移动端的应用质问你，为何别人家的这么流畅，你的卡成了狗。在我们找理由解释原因的时候，或许我们应该更多的审视审视自己，是否离淘汰不远了？当我们觉得舒服的时候，是否就是与同行拉开距离的时候？与传统行业相比，我们有很多的无奈，但是拥有一颗匠心对行业的赤诚之心，不管发展有多快，这些东西都永远不过时。 匠心在我看来是一种精神的反映，在金钱至上的时代，我们所缺少的一种宝贵品质。 书归正传，今日调休，闲来无事，于是又去了一趟铜屋，第三次去发现了前两次所未曾发现的精彩内容。虽然铜屋也是浓浓的商业气息，但至少它的作品独一无二。拍了一些照片，各位看官可做个鉴赏（图片放于七牛云，流量党请慎重观看！）]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络现状-性能优化]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%BD%91%E7%BB%9C%E7%8E%B0%E7%8A%B6-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景互联网正在呈爆发式的增长，我们创建的web平台也是如此。我们通常没有考虑到用户网络的连通性和使用背景。我们还没有建立起同理心和对形式变化的认知，更不用说对性能的考虑。 现今网络状况现状： 地球上74亿人口中，只有46%的人能够上网，平均网络速度为7Mb/s。更重要的是93%的互联网用户都是通过移动设备上网的——不去迎合手持设备是不可原谅的。数据往往比我们想象的昂贵的多——购买 500MB 数据的价格在德国要为此工作 1 个小时，而在巴西需要 13 个小时。 我们的网站表现的也不尽如人意——平均体积大约是第一版Doom游戏的大小(3MB左右)。图片可以轻松占用1.7MB，而javascript平均为400KB。不仅仅只有web平台，本地应用程序也有同样的问题，如为了修复某些bug，不得不下载200MB的应用。 技术人员经常会发现自己处于特权地位。拥有新型高端的笔记本、手机和快速的网络连接。我们很容易忘记，其实并不是每个人都有这样的条件（实际上只有少部分人而已）。 如果我们只站在自己而不是用户的角度来构建 web 平台，那这将导致糟糕的用户体验。 我们如何通过在设计和开发中考虑性能来做得更好呢？ 资源优化最能明显提升性能但未被充分利用的方式是，从了解浏览器如何分析和处理资源开始。事实证明，当浏览器解析和立即确定资源的优先级时，在资源发现方面表现得非常不错。 如果请求包含用户视口渲染所需的资源，那该请求就是关键请求。 对于大多数网站，关键请求可以是 HTML、必要的 CSS、LOGO、网络字体，也可能是图片。事实证明，在大多数情况下，当资源被请求时，许多其他不相关的（JavaScript、追踪代码、广告等）也被请求了。不过我们能够通过仔细挑选重要资源，并调整它们的优先级来避免这种情况发生。 通过&lt;link rel =&#39;preload&#39;&gt;,我们可以手动强制设置资源的优先级，来确保所期望的内容按时渲染。这种技术可以明显改善“交互时间”指标，从而使最佳用户体验成为可能。 &lt;link rel =&#39;preload&#39; href=&quot;sytle.css&quot; as=&quot;style&quot;&gt; 通用性能清单： 主动缓存 启用压缩 优先关键资源 使用 CDN 图片优化页面传输的大部分数据通常都是图片，因此优化图片可以带来很大的性能提升。有许多现有的策略和工具可以帮助我们删除多余的字节，但首先要问的是：“图片对于传达后续的信息和效果至关重要吗？”。如果可以移除，不仅可以节省带宽，还可以减少请求。 在某些情况下，我们可以通过不同的技术来实现同样的效果。CSS 有很多具有艺术性的属性，例如阴影、渐变、动画和形状，这就允许我们用具有合适样式的 DOM 元素来替代图片。 选择正确的格式 如果必须使用图片，那确定哪种格式比较合适是很重要的。一般都在矢量图和栅格图之间进行选择： 矢量图形：与分辨率无关，文件通常比较小。特别适用于 LOGO、图标和由简单图形（点、线、圆和多边形）组成的图片。 栅格图像：表现内容更丰富。适用于照片。 做出上面的决定后，有这样的几种格式供我们选择：JPEG、GIF、PNG-8、PNG-24 或者最新的格式，例如 WEBP 或 JPEG-XR。既然有这么多的选择，那如何确保我们选择的正确性呢？以下是找到最佳格式的基本方法： JPEG：色彩丰富的图片（例如照片） PNG–8：色彩不是很丰富的图片 PNG–24：具有部分透明度的图片 GIF：动画图片 尝试新格式有这样几种由浏览器厂商开发的新图片格式：Google 的 WebP，Apple 的 JPEG 2000 和 Microsoft 的 JPEG-XR。 WebP是最具有竞争力的，支持无损和有损压缩使得它被广泛应用。无损 WebP 比 PNG 小 26%，比 JPG 小 25-34%。74% 的浏览器支持率及降级方案使它可以安全地被使用，最多可节省 1/3 的传输字节。JPG 和 PNG 可以通过 Photoshop 和其他图像处理程序，也可以使用命令行（brew install webp）将其转换为 WebP。 使用工具和算法进行优化即便使用了高效的图片格式也需要后续的处理和优化。这一步很重要。 如果你选择了体积相对较小的 SVG，它们也需要被压缩。SVGO 是一个命令行工具，可以通过剥离不必要的元数据来快速优化 SVG。另外，如果你喜欢 Web 界面或者由于操作系统的限制，也可以使用 Jake Archibald 的 SVGOMG。由于 SVG 是基于 XML 的格式，所以它也可以被服务端 GZIP 压缩。 ImageOptim 是大多数其他图片格式的绝佳选择，它将 pngcrush、pngquant、MozJPEG、Google Zopfli 等一些不错的工具打包进了一个综合的开源包里面。作为一个 Mac OS 应用程序、命令行界面和 Sketch 插件，ImageOptim 可以轻松地用于现有的工作流中。大多数 ImageOptim 依赖 CLI 都可以在 Linux 或者 Windows 平台上使用。 选择工具时，请确保它们能达到预期并适合团队的工作流。最好能自动化优化，这样所有图片都是优化过了的。 响应式图片十年前，也许一种分辨率就能满足所有的场景，但随着时代的变化，响应式网站现今已截然不同。这就是为什么我们必须特别小心地实施我们精心优化的视觉资源，并确保它们适应各种视口和设备。幸运的是，感谢响应式图像社区组织，通过 picture 元素和 srcset 属性（都有 85%+ 的浏览器支持率），我们可以完美地做到。 srcset 属性srcset 在分辨率切换场景中表现得非常不错 —— 当我们想根据用户的屏幕密度和大小显示图片时。根据 srcset 和 sizes 属性中一些预定义的规则，浏览器将会根据视口选择最佳的图片进行展示。这种技术可以节省带宽和减少请求，特别是对于移动端用户。 1234567&lt;img srcset=&quot;cat-320w.jpg 320w, cat-480w.jpg 480w, cat-800w.jpg 800w size=&quot;(max-width:320px) 100vw, (max-width:480px) 80vw, 800px&quot; src=&quot;cat-800w.jpg&quot; alt=&quot;Cat&quot;&gt; picture 元素picture 元素和 media 属性旨在更容易地通往艺术殿堂。通过为不同的条件提供不同的来源（通过 media-queries 测试），无论分辨率如何，我们始终能聚焦在最重要的图像元素上。 123456&lt;picture&gt; &lt;source media=&quot;(min-width:40em)&quot; srcset=&quot;big.jpg 1px, big-hd.jpg 2x&quot;&gt; &lt;source srcset=&quot;small.jpg 1px, small-hd.jpg 2x&quot;&gt; &lt;img src=&quot;fallback.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt; 使用图片 CDN图片性能的最后一步就是分发了。所有资源都可以从使用 CDN 中受益，但有一些特定的工具是专门针对图片的，例如 Cloudinary 或者 imgx。使用这些服务的好处远不止于减少服务器流量，它还可以显著减少响应延迟。 CDN 可以降低重图片站点提供自适应和高性能图片的复杂度。他们提供的服务各不相同（价格也不同），但是大多数都可以根据设备和浏览器进行尺寸调整、裁剪和确定最合适的格式，甚至更多 —— 压缩、检测像素密度、水印、人脸识别和允许后期处理。借助这些强大的功能和能够将参数附到 URL 中，使得提供以用户为中心的图片变得轻而易举了。 图片性能清单 选择正确的格式 尽可能使用矢量图 如果变化不明显，则降低质量 尝试新格式 使用工具和算法进行优化 学习 srcset 属性和 picture 元素 使用图片 CDN 优化网络字体]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017电影经典语录]]></title>
    <url>%2F2018%2F01%2F21%2F2017%E7%94%B5%E5%BD%B1%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[别让这些痛苦消失，也别丧失你感受到的快乐。————《请以你的名字呼唤我》 欲要得到救赎，必先承受痛苦。————《看不见的客人》 现在车有了，歌也有了，你倒没兴致了。————《相爱相亲》 原来我们人生的本体生来就是破破烂烂，所以才会穷其一生不停地在缝缝补补。————《人生密密缝》 死亡不是真的逝去，遗忘才是永恒的消亡。————《寻梦环游记》 等你拿到这个角色，你必须要付出一切，全力以赴，这是你的梦想。————《爱乐之城》 每个人心里都有一团火，路过的人只看到烟。————《至爱梵高·星空之谜》 用权力得来的利益终究会被新的权力所没收。————《人民的名义》 很多事情现在都不能做了，你们现在可能觉得这“不正常”，但时间会改变一切，这会成为新“正常”。————《使女的故事 第一季》 灰心丧气会使人成长，但这只限年轻人！现在的我们需要的不是成长，而是结果。————《紧急救命3》 敌人一直都胜券在握，但我们依旧奋战如初，这就是我所知道的全部意义。————《权力的游戏 第七季》 你是我认识的最渣的混蛋，也是唯一让我感到有意义的同伴，我的人生需要你。————《马男波杰克 第四季》 心一旦碎了，就会永远一直碎着。————《海边的曼彻斯特》 一个始终不被善待的人，最能识别善良，也最珍惜善良。————《芳华》 真正值得在乎的东西，不会越来越多，只会越来越少。————《怒》 有时候白纸一张更能呈现无尽可能。————《帕特森》 有时候如果你爱一个人，就要当一个陌生人。————《银翼杀手2049》 你的超能力是什么？ - 有钱。————《正义联盟》 我笔下的人物没法离开那里，而我却永远无法回去。————《杰出公民》 我们所爱的人，是永远不能被替代的。————《弗兰兹》 我想他们不会回来了。————《鬼魅浮生》 尽管知道整个旅程，知道它通向哪里，我仍然倾心接受，欢迎它的每一个时刻。————《降临》 生如逆旅单行道，哪有岁月可回头，越往前走回头越难，于是乎永别。自欺欺人者会说无憾，心里其实明白的，没办法的办法才叫坦然。唯一能够做的，不过是尽早回头看一看，多看几眼。趁还来得及，趁还不算晚。趁故事尚在，趁人还没走远。 其实这似曾相识的感觉，世上无数人曾的短暂拥有过吧，譬如你，比如我。可惜你我羞涩矜持，你我不敢惜缘，任凭小羽毛飘过眼前掠过指尖，也怯于伸手去捉弯腰去捡。故而，大多似曾相识的第一眼第二眼，大都终于插肩而过，止于雁渡寒潭。再奇妙的遇见，一个转身也就淡了。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常用方法]]></title>
    <url>%2F2017%2F12%2F23%2FJS%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言看过不少技术博客文章，总能看到一句话，输出便是最好的输入。要想更好的掌握一门语言，要学会不断地去输出东西，这样才会增加更多的记忆点。当然这个过程可能比较耗费时间。 既然标签是javascript，那我就顺带提提这门语言，由最初的一门脚本语言，但现在越来越多领域应用到了它，未来可能一个应用全部由javascript构建完成。很多人疯狂的游走于各个语言的学习之中，但是否真正掌握了一门语言？听过一句话，如果连一门语言也写不好的话，那么其他语言你一定写不好，我们在拓展广度的同时是否真正对它进行了深度的扩展？ 正文JavaScript数据强制转换 Number() 转换成数值类型 String() 转换成字符串类型 Boolean() 转换成布尔类型 parseInt() 将字符型转换为整形 parseFloat() 转换为浮点型 JavaScript数组对象 arr.push(数组元素...) 向数组的末尾添加新的元素，返回值是新数组的长度。可以一次添加多个元素。 arr.unshift(数组元素...) 向数组的开头添加新的元素，返回值是新数组的长度。可以一次添加多个元素。 arr.pop() 删除数组的最后一个元素，返回删除的元素。 arr.shift() 删除数组的第一个元素，返回删除的元素。 arr.splice(index,数量,添加的元素...) index：从何处开始添加/删除 数量：规定删除的个数，如果是0，则不删除 需要添加的元素，可以当做替换的元素 若从arr中删除了元素，则返回的是含有被删除元素的数组。 arr.split() 字符串分割为数组 arr.join([分隔符]) 把数组元素按照指定分隔符组合成一个字符串，如果没有指定分隔符，默认是用’,’ arr.slice() 从截取指定的开始位置，到结束位置(不包括)的元素。如果不指定结束位置，则从指定的开始位置截取到结尾。 支持负数(-1)，返回新数组。 arr.concat() 数组的连接，连接两个或更多的数组，并返回新数组，但是对原数组没有任何影响。 arr.sort(fun) 数组的排序，默认是按照字符编码的顺序进行排序。如果要实现其它排序规则，则要传入一个参数。(ab,a=b) 后续研究下 JavaScript字符串对象 str.charAt(num) 返回在指定位置的字符 str.charCodeAt(num) 返回指定位置字符的Unicode编码 str.fromCharCode() 接收一个或多个指定的Unicode值，然后返回一个或多个字符串(var n = String.fromCharCode(99);) str.indexOf(&quot;&quot;) 返回某个指定字符串，在字符串中首次出现的位置 str.lastIndexOf(&quot;&quot;) 返回指定的字符串最后出现的位置 str.match() 在字符串中检索指定的值，返回的值就是指定的值 str.search() 只能用于正则 str.replace() 将字符串中的一些字符替换为另外一些字符。 str.slice() 从指定的开始位置，到结束位置(不包括)的所有字符串。如果不指定结束位置，则从指定的开始位置，取到结尾。slice参数可以是负数 str.substring(start,end) 从指定的开始位置，到结束位置(不包括)的所有字符串。如果不指定结束位置，则从 指定的开始位置，取到结尾 str.substr(start,length) 从指定的位置开始取指定长度的字符串。如果没有指定长度，从指定开始的位置取到结尾。 str.split(&quot;分割位置&quot;,[指定的长度]) 将一个字符串分割成数组 str.toLowerCase() 用于把字符串转换为小写 str.toUpperCase() 用于把字符串换位大写 JavaScript Math对象结尾很多方法比较常用，但是在学的时候并没有太多感触，所以，应用是最好的学习方式。未完待续…]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感悟]]></title>
    <url>%2F2017%2F11%2F16%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[2017.11.16最近总想提笔写一篇博文，技术方面或者感悟方面，关于技术方面的问题，最近一个月基本上每天都有在github上提交代码，主要就是工作中遇到的一些问题，然后抽空闲时间研究研究这些技术方面的点，做一些简单的练习，然后把它当成自己的一个积累放到github上，主要的目的还是为了让自己更好的理解相关方面的知识，比如md5加密、图片验证码的生成、各式各样的插件(three.js、弹框、表格、相册等)一些诸如angular.js框架的应用。很多都是工作中遇到或者被问到，然后就去研究相关方面的问题，大部分情况下都能达到自己的预期效果。[感兴趣的person可以去看看，地址:http://gwem.tk/works] 虽然本人私底下接触到的活物不多，但是总还是被问到关于工作的一些问题，技术方面或者是工作状态方面，比如有大四同学会问到工作中会是一个什么样的流程，然后我回答的是，如果是实习生的话可能会有相关的领导会带你做一些项目，但是不要抱的期望太高，领导也有领导的工作，你只能是在一些关键的点上问问领导，不可能什么都去问，这样的话招你进来就没有任何意义，公司需要的是一个能够解决问题的人，而非整日像一个小学生一样缠着问问题的人，问的多了，即便脾气再好的人也会烦。 所以，学习能力非常重要，就是你解决问题的能力，不要想着就像学校一般，第二天去了会有老师专门解决头一天遗留下来的问题，这些问题都需要你自己来解决，所以很多情况下，空闲时间将会是一个很好的解决问题的时间段，多充分利用这段时间，研究研究自己所遇到的问题，或者优化优化自己之前写的代码，多看看书。。。 关于目前的工作状态，工作时间段完成公司项目，下班之后一般情况下不会考虑工作的事，研究研究自己感兴趣的技术，另一点，公司鼓励员工运动，所以，周六日的时候也会抽时间外出跑跑步，看看美景，不过通常情况下都是夜晚跑，什么都看不到。。。 很多情况下，需要给自己一个独处的时机，这样我感觉会有这么一段时间，你的头脑是完全清醒的，你可以静静反思你所遇到的问题，比如，有时候也会发个疯，座个地铁，从起点站座到终点站，又坐了回来。往往一个小时过去了，平常心烦不想看的一些文章也看完了，因为这个时候我们周边对我们的诱惑最小，我们不需要被手机、电脑给缠住，那个时间段只会做相对有意义的一件事，心中也会多一份充实感、少一分空虚。 2017年还有一个月就到年尾了，至今为止，github代码提交数有289次，一个半月，我的目标是突破500次，平均每日需要提交代码5次左右，而我也相信这个目标一定可以完成(截止到12月31号，Github代码提交有410次，好吧，确实打脸了…) 2017.12.7每一次项目都会或多或少有所收获，耗时近一个月的项目也终于结束了，长呼一口气，没有了项目开发过程中那般大压力，有必要来波总结，将这段时间项目开发过程中遇到的问题以及解决方式做个分享。 关于页面制作方面，没什么可说，值得一提的是，为了使图片加载速度更快，在PS中保存Web所用格式时，可进行二次压缩，将最大单张图片压缩到100K左右，大大提高了页面图片访问速度 压缩地址：https://tinypng.com/ 没错，就是这只贱了吧唧的熊猫。 有关页面制作的另一个问题便是，关于写出来网页的高度适配问题，目前也是比较头疼的问题。设计出设计稿可能是针对的大屏幕，宽度无可厚非，都是在1200px内宽之中。值得一提的是高度问题，在大屏幕中看起来效果可能非常好，但是到了小屏幕中，可能有些东西就放不下，显示不全，尤其是弹框之类的东西（设置了全屏幕固定定位，无法拉动滚动条），后续会继续深入研究 这次项目比较大的几个点可能就是： 增加了扫码登录(二维码由前端生成，选用jquery-qrcode插件来生成图片二维码)图片上传问题(图片上传-上传到接口前对图片的处理-返回图片后的页面展示 图片多选标签属性：) 写完之后发现也没那么复杂，但其实很大一部分时间耗费在了这儿图片拖拽问题(使用插件jquery.dragsort-0.5.2.js解决) 后来才发现，图片拖拽也就是页面显示效果不同而已，它其实并不走接口，也就是在整个流程结束之后，将相应顺序的图片路径存储到数据库中点击图片滚动(其实就是一个简单的轮播效果，不过说来惭愧，到现在还有一些问题)其余问题是关于JS一些不太熟悉方法的应用，比如$.trim replace indexOf 包括一些函数封装 自定义方法、函数的一些写法 ajax post get方式传递数据 正则匹配等等 遇到不少奇奇怪怪的问题，好在度娘和github基本上都可以解决掉，剩余一些找不到解决方式的问题便靠运气了。 一个项目上线之后但并未结束，代码更新维护，隐藏的bug修改… 方法的整理等等 so , hold on and never give up! 完！ 2017.12.24周边弥漫着圣诞节来临的热闹，商场促销打折，各个公司门口也都放着一刻圣诞树，给人一种浓浓的过节气氛。网上看到有人评论，说中国人不应该过这样的节日，崇洋卖外…但是我觉得挺好的，平日工作生活本就无趣，偶尔有这么一两天热闹时节，多好，外国人不也在过咱们的节日么？ 跑步路途中想到一个有意思的话题，每周一公司晨会的时候，总会挑选几个人谈谈自己的梦想，大部分人上去都是一两句话匆匆结尾，而且如出一辙。我认为梦想不一定只有一个，我们可以每一天，每一个月，每一年都可指定一个梦想。我觉得梦想就是你想要实现，但是还没有实现的事物。因而，你想想，是不是有很多你想要实现的事情？ 如果每个人都能够拥有瞬间移动的能力、都如闪电侠一般，这样我们就不用担心每天上班迟到。而且每天下班之后可以瞬间移动到家中，吃着家人做的热饭，我们不在需要租房，不需要偿还房贷，可以舒舒服服躺在家中。但如果真有那么一日，或许又会有许多额外的考虑，交通工具或许也就没有存在的必要，大街上也不会再有那么热闹的人潮… 文章tags:异想天开 2018.02.25很久之前买了一口锅，没怎么用，近来想到既然买了就不能把它浪费了，于是乎便每日开始烧饭，每日都用它。偶然一想，当我们站在上帝视角去看这口锅的同时，是否别人也在用同样的视角审视我们？那么锅可能没有情感，那么人呢？ by:大锅]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VH和VW实现流体排版]]></title>
    <url>%2F2017%2F10%2F22%2FVH%E5%92%8CVW%E5%AE%9E%E7%8E%B0%E6%B5%81%E4%BD%93%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[前言不像响应式布局，通过media query，设置几个变化点来适配，流体排版通过调整大小，适配所有设备宽度。这个方法可以使我们开发的网页，在几乎所有屏幕尺寸上都可以使用。但出于一些原因，它的使用率还远远没有响应式技术高。 流体排版视口（viewport）单位,使流体排版在页面上应用变为可能。视口单位是根据浏览器的视口尺寸的百分比来定义的。 举个例子，1视口宽度（vw）等于视口宽度的1%，它不同于百分比的地方是，它的宽度是依赖于视口的宽度的，而百分比是元素的祖先元素来决定的。 视口单位，不同于其它单位，它不依赖于基础字体的大小。这种差别很重要，使它变得有意义而且独特。 可以使用的4种视口单位： vw:视口宽度(viewport width) vh:视口高度(viewport height) vmin:视口宽度或高度，选择小的那个 vmax:视口宽度或高度，选择大的那个 使用流体排版最简单的方法，是把html元素的font-size，设置为一个流体单位： 1html&#123;font-size:2vw;&#125; 这个例子中，我们把根元素的字体大小设置为2vw。这里我们已经修改了根元素字体大小。因为直接或间接使用的em或rem单位，都是依赖于”root rem”的，所以也变成流体的了。例如 1h1&#123; font-size:2em; &#125; h1的font-size:2em，如果它依赖的是根节点的字体大小，那么 font-size:2*2vw=4vw。 只使用视口相关的单位也有一些不足。 无法精确地控制放大比率。 没有最大或最小字体大小。 和使用font-size相比，用户更容易使用像素来声明大小。 控制视口单位来设置最小最大font-sizehtml设置为font-size:2vw的方法，看起来既是流体的，调用起来也很方便，但有些场景没法覆盖。视口单位不是万能的，它也需要使用一些其它的方法，来解决无法覆盖的场景。由于视口单位都是依赖于视口的，在非常小的屏幕上，会得到很小的字体大小，已致无法查看。（chrome的最小字体是12px，好像可以解决了。） 理想情况下，我们可以通过设置最小字体来避免这种情况，但CSS中没有min-font-size这个属性。通过一些横向思维，我们可以得到实现这种效果的方法。 首先，我们可以使用calc()表达式。 1html&#123; font-size: calc(1em + 1vw); &#125; 这样就算我们在一个0宽度的视口中，font-size的大小也会存在，并为1em。在大的屏幕上，1vw也会在最小字体1em的基础上增加。但是这种解决方法也不是最理想的。通常我们只是想在一些小的屏幕上去设置最小字体。我们可以使用media query来解决： 1234@media screen and (min-width: 50em) &#123; html &#123; font-size: 2vw;&#125;&#125; 上面代码设置，是仅在当视口宽度大于50em的时候，使用流体。虽然这样能很好的工作，但也表明会在固定值和流体值之间跳动。为了解决这个问题，我们可以计算出流体值和固定值之间的对应关系。 如果默认字体大小是16像素，并且2vw是2%的视口宽度，那么可以知道在800像素的视口时两个值是相等的。（16/(2/100)=800） 因为我们想在media query中，使用em单位来匹配。现在来换算一下像素到em。800像素除以16(1em = 16px)：800/16=50。我们也可以使用这个公式来算1/(2/100)=50。和上面例子里使用的变化条件一样，2vw对应的是50em。最终，我们得到了一个不会在固定和流体之间，产生跳动变化的值。 同样的可以用公式去算出最大字体。如果我们想使用的最大字体是24像素，那么对应的视口宽度就是24/(2/100)=1200px。换算成字体，就是1.5/(2/100)=75em。如果视口宽度大于75em时，我们就把字体大小设置成固定值。 1234@media screen and (min-width: 75em) &#123; html &#123; font-size: 1.5em; &#125;&#125; 这些计算都不是太难，下面做了一个表格，显示了各视口宽度，流体大小对应的字体大小。 通过这个表格，你可以获得一些控制视口单位变化。使用单独的视口单位，可以只看对应的一列中的字体大小。 控制缩放比率在不使用media query的情况下，我们不可能解决，在400像素的屏幕上显示16像素的字体，在800像素显示24像素的问题。 还有，你可能会说，可以使用设置最大最小字体的方式，来解决这个问题。但这里不是像那样来处理的。 我们要怎么去解决这个问题呢？答案是使用calc()。使用calc和视口单位配合，我们可以用高级的流体排版，可以精确地控制一定范围内的视口宽度使用特定大小的像素值。这里需要建立一个基本的数字函数： 保持理想的阅读长度在《The elements of typographic style》,Robert Bringhurst 提出一个合理的阅读长度 大约是45到75个字符的长度 同样的规则可以直接运用到流体排版上，很多情况下，文件缩放实现一致的阅读长度是可能的。 在响应式方法里，我们在media query里设置不同的字体大小，调整容器的宽度，来保持正确的阅读长度。然而，使用流体排版，调整media query下的值方法已经行不通了。 只是设置容器的大小，使它的比率和字体相同。我们可以使用像上文提到的计算font-size的方法，使用 calc（）来计算width属性的值。这可以保持阅读长度-而且样式表也更容易阅读和维护了。 在非常小的屏幕维护理想的阅读长度是不可能的。这种情况下，我们选择把容器的宽度设置为智能移动设备的宽度。 使用流体排版如果要使用流体排版，要先想清楚要使用哪种解决方案。 如果整个设计都是流体的，可以考虑使用rem来定义流体，可以声明html字体大小为一个流体单位。可以使用em和rem来定义所有设计部分。 小心选择你的最大最小字体。关于这点，你需要决定是否直接使用视口单位或对更加精确地缩放比率。如果是后者，使用Sass,LESS或PostCSS插件中的函数，可以更简单实现。 确保获得了正确的字体的最大最小值。这是问题的关键。一旦你选定了根元素的字体大小，其它的所有组件都是依赖这个值来计算的。项目中如果后面要调整这个值，那么整个项目都要调整。 不要忘记，在使用流体排版之前定义一个默认的字体大小。默认字体大小，用来在那些不支持流体字体大小的浏览器上使用的，这个值不需要和字体最小值 相同。 原文链接： 使用VH和VW实现真正的流体排版]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是内存泄漏?]]></title>
    <url>%2F2017%2F09%2F30%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[前言明天就是国庆节，各位小伙伴是不是很兴奋？尤其对程序员而言，能够有一段时间不需要考虑项目bug，想想都觉得不错。近来项目比较赶，加班加点码代码，改需求，但是不可避免的还是码出了新的bug，先就最近一段时间的工作谈谈自己的一些体会…… 在项目评审阶段，产品提出了需要做A、B测试？What?什么是A、B测试，好吧，其实就是一个功能的两种不同版本，需求是希望用户能够随机的切换两种不同版本，进而对不同版本的数据做统计。于是考虑再三之后选择了通过cookie来实现两种不同版本的切换，实现思路：判断客户端是否存在对应类型的cookie，若存在，则通过存在类型的cookie值来显示相应的版本，若不存在，则随机生成一个cookie: 123456789101112131415if($.cookie(&apos;class&apos;))&#123;&#125;else&#123; if(Math.random()&lt;0.5)&#123; $.cookie(&apos;class&apos;,&apos;A&apos;); &#125;else&#123; $.cookie(&apos;class&apos;,&apos;B&apos;); &#125; &#125;if($.cookie(&apos;class&apos;) == &apos;A&apos;)&#123; 展示A版本信息&#125;else&#123; 展示B版本信息&#125; 紧接着，有一个需求是希望能够实现PC和移动端拖拽进度条的功能(PC端需要兼容到IE7)，我们所知道PC端鼠标拖拽用到了onmousedown、onmousemove和onmouseup事件，而移动端显然无法用相同的事件，最后选择了利用Html5的触摸事件，ontouchstart、ontouchmove、ontouchend，PC和WAP端的实现思路：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253PC 端：var scale = function (btn,bar,title)&#123; this.btn=document.getElementById(btn); this.bar=document.getElementById(bar); this.title=document.getElementById(title); this.step=this.bar.getElementsByTagName(&quot;div&quot;)[0]; this.init();&#125;;scale.prototype=&#123; init:function ()&#123; var f=this,g=document,b=window,m=Math; f.btn.onmousedown=function (e)&#123; var x=(e||b.event).clientX; var l=this.offsetLeft; var max=f.bar.offsetWidth-this.offsetWidth; g.onmousemove=function (e)&#123; var thisX=(e||b.event).clientX; var to=m.min(max,m.max(0,l+(thisX-x))); f.btn.style.left=to+&apos;px&apos;; f.ondrag(m.round(m.max(0,to/max)*100),to); b.getSelection ? b.getSelection().removeAllRanges() : g.selection.empty(); &#125;; g.onmouseup=new Function(&apos;this.onmousemove=null&apos;); &#125;; &#125;, ondrag:function (pos,x)&#123; this.step.style.width=(Math.max(0,x)+15)+&apos;px&apos;; this.title.innerHTML=pos+&apos;%&apos;; &#125;&#125;new scale(&apos;btn&apos;,&apos;progress&apos;,&apos;title&apos;);Wap端：var start,end,s,btn1_width;btn1_width = $(&apos;.btn1&apos;).width()/2;$(&apos;.btn1&apos;).on(&apos;touchstart&apos;, function (e) &#123; var start = parseInt(e.originalEvent.changedTouches[0].pageX); s = parseInt($(this).css(&quot;left&quot;)); $(document).on(&quot;touchmove&quot;, function (e) &#123; end = parseInt(e.originalEvent.changedTouches[0].pageX); var width = $(&apos;.progress1&apos;).width(); var move = end - start; localStorage.progress = s + move; if ((s + move) &gt; 0 &amp;&amp; (s + move) &lt; width) &#123; $(&apos;.btn1&apos;).css(&#123;left: s + move + &quot;px&quot;&#125;); $(&quot;.pro_act1&quot;).css(&#123;width: s + move + btn1_width + &apos;px&apos;&#125;); &#125; &#125;)&#125;)$(&quot;.btn1&quot;).on(&quot;touchend&quot;, function (e) &#123; $(this).off(&quot;touchmove&quot;);&#125;); 当然，实现这样的业务代码，无论如何都有前人的方法可以去借鉴，那么在开发过程中，其实比起业务逻辑更为麻烦的事我认为是在前人的基础上做开发，不知不觉就码出了新的bug，因为你所修改的内容有些深层次的含义你没办法面面俱到的都想到，不知不觉就制造出了新的bug，然后就开始了改bug的’美好时光’…… 正文书归正传，什么是内存泄漏？我们该如何解决内存泄漏？这个在我们码代码的过程中可能不知不觉就会产生的问题？ 什么是内存泄漏？程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector） 垃圾回收机制垃圾回收机制怎么知道，哪些内存不再需要呢？ 最常使用的方法叫做”引用计数”（reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。 12const arr = [1, 2, 3, 4];console.log(&apos;hello world&apos;); 上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。 如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。 123let arr = [1, 2, 3, 4];console.log(&apos;hello world&apos;);arr = null; 上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 内存泄漏的识别方法怎样可以观察到内存泄漏呢？ 经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。 打开开发者工具，选择 Timeline 面板 在顶部的Capture字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。 WeakMap前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。 123456const wm = new WeakMap();const element = document.getElementById(&apos;example&apos;);wm.set(element, &apos;some information&apos;);wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 结语生命不息，改bug不止…参考文章：JavaScript 内存泄漏教程 - 阮一峰的网络日志]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端兼容性及部分功能设置]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%8A%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[概要本文档针对移动前端开发，包括 Hybrid 里面的web页面，非 Native 应用。 适用所有经验适用于：iOS6.0+, Android4.0+ 兼容性CSS伪类:active如果你想使用元素的伪类来实现 按下激活 状态，那么你需要知道以下问题： iOS上的几乎任何浏览器，定义元素的伪类 :active 都是无效； Android上，Android Browser 和 Chrome 都支持伪类 :active ，其它第三方浏览器有部分不支持； 定义了 :active 并且当前浏览器环境支持，当手指在滚动或者无意间的划过时，:active 状态都会被激活； 为了规避上述所有的问题，如果需要 按下激活 状态，推荐使用 js 新增一个 className 清除输入框内阴影iOS上的几乎任何浏览器输入框（input, textarea）默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭： 123456789101112input,textarea &#123; /* 方法1: 去掉边框 */ border: 0; /* 方法2: 边框色透明 */ border-color: transparent; /* 方法3: 重置输入框默认外观 */ -webkit-appearance: none; appearance: none;&#125; 修正iOS输入框禁用文本色在 iOS 上，如果将输入框 disabled，此时输入框内的文字颜色将比 color 所定义的要浅，并且无法通过给输入框的伪类 :disabled 定义 color 来修正。 想解决这个问题，可以作如下设置，定义输入框的文本填充色： 123input:disabled &#123; -webkit-text-fill-color: #000;&#125; 需要注意的是，在 Mac 上的 Safari 也有同样的问题。 Samsung S4圆角BugSamsung S4 手机在 Android Browser4.4.2 上（其他版本未测），如果你使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题： 12345678910.test &#123; border: 2px solid red; width: 50px; height: 50px; border-radius: 50%; background-color: gray; box-shadow: 0 2px 5px rgba(0, 0, 0, .3); -webkit-transform: translate(0, 0) translatez(0); transform: translate(0, 0) translatez(0);&#125; 1&lt;div class="test"&gt;&lt;/div&gt; 如上代码，-webkit-transform: translate(0, 0) translatez(0) 将会导致圆角无法包裹住 background-color。 当然，-webkit-transform: translate3d(0, 0, 0) 也是一样的，所以如果你的某个场景是这样的，那么可以直接使用 -webkit-transform: translate(0, 0) 来避免这个问题。 边框圆角致背景溢出在红米和OPPO等手机某些版本的 Android Webview 中，如果一个元素定义了 border + border-radius，这时如果该元素有背景，那么背景将会溢出圆角之外。 之所以会出现这个问题：其主要原因是因为CSS对背景裁剪（background-clip）有不同的处理方式，通常它可以是 border-box | padding-box | content-box 这3种方式。 浏览器的默认裁减方式是 border-box，即溢出 border 之外的背景都将被裁减。 对于上述无法裁减边框之外背景的手机，将值定义为 padding-box | content-box 都能fix这问题，不过更推荐使用 padding-box。因为使用 content-box，如果定义了 padding 不为 0，背景将无法铺满元素。 一个失败的圆（圆角）在移动平台上开发时，用CSS画一个圆很简单，只需要一句代码： 123.circle &#123; border-radius: 50%;&#125; 不过，在 Android Browser2.* 上，这个定义将会失效，而显示为默认的矩形。 因为 Android Browser2.* 不支持以 百分比 作为 border-radius 的值，所以如果你需要兼容 Android Browser2.*，那么你可以这样： 12345.circle &#123; width: 10rem; height: 10rem; border-radius: 5rem;&#125; 如果你觉得这样定义不够灵活，想懒一点，那么其实可以给 border-radius 预设一个比较大的值，比如 100rem，用以避免当元素的尺寸变了，圆角半径也得跟着变，除非元素的尺寸超出了你预设的阀值。 不要使用伪元素动画有的时候你可能会为了减少页面上的DOM数，而使用伪元素。但如果你想给伪元素增加 animation 或者 transition 动画，这时候会碰上支持性问题。 如果你的项目需要支持以下系统版本，那么建议直接使用真实元素： iOS Safari6.1及以下 Android Browser4.1.*及以下，包括一些深度定制的系统，比如： 魅族 - Flyme OS 4.1.1.1C及以下（比这高的版本尚未测试过）- 咱国产能别这么坑么（安卓版本为4.4.4的魅族MX4 pro） :checked与兄弟选择符一起使用的bug在 Android Browser4.2.*及以下（可能版本稍有出入）（包括坑爹的Flyme），如果你有这样一段代码： 123input:checked ~ .test &#123; background-color: #f00;&#125; 那么将无任何效果，如果你想使得上述代码生效，有2种方式： 第一种，使用 input 和 + 进行激活： 1234html + input &#123;&#125;input:checked ~ .test &#123; background-color: #f00;&#125; 只要存在 input和 + 选择符配合使用的选择器（空规则集也行）即可使得上述代码激活生效。 第二种，直接换成 +： 123input:checked + .test &#123; background-color: #f00;&#125; 为什么flex布局不生效 使用块级元素作为 flex items（flex子项）； Android Browser4.3及以下，iOS Safari6.1及以下 的 flex子项 需要使用块级元素，在这些版本之上还可以使用行内块元素 在这些版本中，如果你发现flex子项之间出现了间隙，或者在未定义换行的情况下子项自身抑或子项之间换行了，或者出现了其它不正常的情况，那么仔细看一下flex子项可能是使用了行内级元素； 当横向布局时，给 flex子项 子项定义 width 为非 auto 的值 Android Browser4.3及以下，iOS Safari6.1及以下 的 flex子项 如果没有显式的定义 width 为非 auto 的值，那么子项分配父元素剩余空间时将会不符合标准预期； 当纵向布局时，给 flex子项 子项定义 height 为非 auto 的值 Android Browser4.3及以下，iOS Safari6.1及以下 的 flex子项 如果没有显式的定义 height 为非 auto 的值，那么子项分配父元素剩余空间时将会不符合标准预期； 为什么小于12px字号不生效如果你是从pc开发转到移动平台的，或者应该记得在pc端，Chrome及后来加入Webkit阵营的Opera都不支持页面字号小于12px，当然你可以通过更改浏览器设置来改变这一情况，然后这并没有什么卵用，不是么？ 不幸的是，在移动端这个限制也依然存在，在Android Chrome上（包括部分版本上的Android Browser），仍然不支持小于12px的字号（测试至Android5.0.2, Chrome46），除此之外，其他浏览器包括iOS上众浏览器都能够很好的支持超小字体。 所以，如果希望你的程序足够安全，尽量不要定义小于12px的字号，或者换一种方式来实现。 题外话：假设你的项目使用了rem，那么不要使用10作为换算因子，原因也如上 chrome中body使用rem失效我知道很多人已经开始使用 rem 作为项目中的单位了。但是遗憾的是，在 Chrome 和 Opera 上，如果我们给 body 元素应用了 rem，那么这个取值将会计算错误。 假设我们有如下代码： 123456html &#123; font-size: 62.5%;&#125;body &#123; font-size: 1.4rem;&#125; 因为大部分浏览器的默认字号都是 16px，所以 html 的字号计算出来应该是 16px * 62.5% = 10px。此时，我们预期 body 的 font-size 为 14px。然而实际情况与我们想象的不太一样，最终 body 的计算值并不是 14px，它忽略了 html 的定义，而是直接使用了浏览器的默认字号作为参照。于是最终计算值为：16px * 1.4rem = 22.4px。测至 chrome 45.0 和 Opera 33.0 仍然存在这个问题，不过 chrome 49.0 和 Opera 37.0 看起来已经被修复了。 为了有效的绕过这个问题，并且实现相同的效果，我们可以将代码修改如下： 123456html &#123; font-size: 62.5%;&#125;body &#123; font-size: 1.4em;&#125; 由于 body 是 html 的直接子元素，所以此时对 body 使用 em 与 rem 的效果是相同的。 不要对html设置百分比字号很严肃的和大家说，如果你在使用 rem 这项技术，那么尽可能不要对html设置百分比大小的字号。比如这样的： 123html &#123; font-size: 62.5%;&#125; 由于大部分浏览器的默认字号是 16px，所以能计算出 html 的字号实际为 10px。我们在 为什么小于12px字号不生效 中说过，部分浏览器会将小于 12px 的字变成 12px 来显示。那么此时，在这些浏览器下，如果我做了这样的定义： 123.demo &#123; width: 10rem;&#125; 你预期得到 10px * 10rem = 100px，但实际上得到的确是 12px * 10rem = 120px。这是非常大的错误，我们应当尽量避免。 与此同时，虽然大部分浏览器的默认字号是 16px，但仍然有使用其它默认值的浏览器，比如我依稀记得 firefox 使用了 15px。而且最重要的是，用户是可以改变浏览器默认字号的，所以你认为的可能并不是你认为的。 所以不要对html设置百分比字号，尤其是不要对它使用计算值比 12px 小的字号。我推荐大家这样做： 123html &#123; font-size: 100px;&#125; 以 100px 作为因子，计算也非常方便。如果你想要设置一个元素的宽度是 20px，那么只需要： 123.demo &#123; width: .2rem;&#125; 功能设置禁止保存或拷贝图像通常当你在手机或者pad上长按图像 img ，会弹出选项 存储图像 或者 拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止： 123img &#123; -webkit-touch-callout: none;&#125; 需要注意的是，该方法只在 iOS 上有效。 取消touch高亮在移动设备上，所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过以下方法来禁止： 123.xxx &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以禁掉： 123html &#123; -webkit-user-select: none;&#125; 快速回弹滚动 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll; Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动； Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除； iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果 在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做： 1234.xxx &#123; overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch; /* 该规则可能引起iOS UIWebView崩溃 */&#125; 设置添加到主屏幕的Web App标题iOS Safari 允许用户将一个网页添加到主屏幕然后像 App 一样来操作它。我们知道每个 App 下方都会有一个名字，iOS Safari 提供了一个私有的 meta 来定义这个名字，代码如下： 1&lt;meta name="apple-mobile-web-app-title" content="Web App名称" /&gt; Android Chrome31.0，Android Browser5.0 也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一 iOS 和 Android 平台定义 Web app 名称的方式，可以使用 title 标签来定义，代码如下： 1&lt;title&gt;Web App名称&lt;/title&gt; 但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。 设置添加到主屏幕的Web App图标当我们将一个网页添加到主屏幕时，除了会需要设置标题之外，肯定还需要能够自定义这个App的图标，代码如下： 1&lt;link rel="apple-touch-icon" href="app.png" /&gt; 不过该方案，在拟物设计的 iOS6及以前 会自动为图标添加一层高光效果，iOS7 已使用了扁平化设计，所以如果使用该方案，在不同版本下得到的效果会不一致。 当然，你也可以使用原图作为App的图标，用以保持各平台表现一致，代码如下： 1&lt;link rel="apple-touch-icon-precomposed" href="app.png" /&gt; 如果你想给不同的设备定不同的图标，可以通过 sizes 属性来定义，形如： 1234&lt;link rel="apple-touch-icon" sizes="76x76" href="ipad.png@1x" /&gt;&lt;link rel="apple-touch-icon" sizes="120x120" href="iphone-retina@2x.png" /&gt;&lt;link rel="apple-touch-icon" sizes="152x152" href="ipad-retina@2x.png" /&gt;&lt;link rel="apple-touch-icon" sizes="180x180" href="iphone-retina@3x.png" /&gt; 规则如下： 如果没有跟相应设备推荐尺寸一致的图标，会优先选择比推荐尺寸大并且最接近推荐尺寸的图标。 如果没有比推荐尺寸大的图标，会优先选择最接近推荐尺寸的图标。 如果有多个图标符合推荐尺寸，会优先选择包含关键字precomposed的图标。 实际情况下，大部分智能手机都接近或者已经达到视网膜屏质量，所以如果想省事的话，可以分别为 iPhone 和 iPad 定义一种高质量的 icon 即可。 该方案在 iOS 和 Android5.0+ 上都通用。 添加到主屏幕时隐藏地址栏和状态栏（即全屏）当我们将一个网页添加到主屏幕时，会更希望它能有像 App 一样的表现，没有地址栏和状态栏全屏显示，代码如下： 1&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; 该方案在 iOS 和 Android5.0+ 上都通用。 添加到主屏幕时设置系统顶栏颜色当我们将一个网页添加到主屏幕时，还可以对 系统显示手机信号、时间、电池的顶部状态栏 颜色进行设置，前提是开启了： 1&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; 有了这个前提，你可以通过下面的方式来进行定义： 1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; content只有3个固定值可选：default | black | black-translucent 如果设置为 default，状态栏将为正常的，即白色，网页从状态栏以下开始显示； 如果设置为 black，状态栏将为黑色，网页从状态栏以下开始显示； 如果设置为 black-translucent，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上； 该设置只在 iOS 上有效。 电话号码识别在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。 关闭电话号码识别： 1&lt;meta name="format-detection" content="telephone=no" /&gt; 开启拨打电话功能： 1&lt;a href="tel:123456"&gt;123456&lt;/a&gt; 开启发送短信功能： 1&lt;a href="sms:123456"&gt;123456&lt;/a&gt; 邮箱地址识别在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。 关闭邮箱地址识别： 1&lt;meta name="format-detection" content="email=no" /&gt; 开启邮件发送： 1&lt;a href="mailto:dooyoe@gmail.com"&gt;dooyoe@gmail.com&lt;/a&gt; 如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下： 1&lt;meta name="format-detection" content="telephone=no,email=no" /&gt; 关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果业务不想出现首字母大写，可以这样： 1&lt;input type="text" autocapitalize="off" /&gt; 关闭iOS输入自动修正在iOS中，默认输入法会开启自动修正输入内容的功能，如果不需要的话，可以这样： 1&lt;input type="text" autocorrect="off" /&gt; 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止： 123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 `meta viewport’]]></content>
      <tags>
        <tag>wap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travel-2]]></title>
    <url>%2F2017%2F09%2F02%2FTravel-2%2F</url>
    <content type="text"><![CDATA[前言作为一名you逼格的“工程师”，一定要时刻想着发技术文章以突显自己高超的专业技术。。。嗯，就是这样！ 南宋御街南宋御街( Southern Song Imperial Street )，是南宋都城临安铺设的一条主要街道。《咸淳临安志》等文献记载，铺设南宋御街一共使用了一万多块石板，但此前的考古发掘却只发现过香糕砖。御街南起皇城北门和宁门（今万松岭和凤凰山路交叉口）外，经朝天门(今鼓楼)、中山中路、中山北路、观桥即今贯桥到今凤起路、武林路交叉口一带，是南宋临安城的中轴线，全长约4185米。它是皇帝于“四孟”（孟春、孟夏、孟秋、孟冬）到景灵宫（今武林路西侧，供奉皇室祖先塑像的场所）朝拜祖宗时的专用道路。 这条街商业化太严重，回来发现就拍了一张郭德纲的照片。好吧，我是钢丝，从大学开始，无数个夜晚就是郭德纲于谦陪我度过。。。 最深刻的有两个地方，一个是江南铜屋还有一个是一家卖包、杂货的小店，先说前者，走进去琳琅满目的工艺品，用现代铜工艺打造，有各种各样的铜制艺术品，佛像、关公像、古代神兽、桥、雷峰塔等等，价格不菲，好几千上万，看的冷汗直冒，生怕撞坏。。。再说说那家卖包的小店，是经过后又折回去去看了看，屋内房顶上挂满了各种各样手工缝制的包、漂亮的手工制品，加上独特的音乐，仿佛置身另一个时空。不经意往周边看了看都是文艺范小女生，异样的眼光正盯着屋内仅有的一个男屌丝，于是，迅速离开。。。 浙江大学之江校区浙江大学之江校区解放前为之江大学所在地，其是基督教美北长老会和美南长老会在中国杭州联合创办的一所教会大学，也是中国的十三所基督教大学之一，之江校区占地面积650亩，校舍建筑总面积7万平方米。现为浙江大学光华法学院和浙江大学人文高等研究院所在地。 不少古建筑还保留在校园内，彰显着它的历史年代气息。校园内绿树成荫，给人感觉倒像是去了一所植物园，走路时战战兢兢，很担心草丛中跑出一只路过的小动物，吓破我这颗脆弱的玻璃心。。。 旁人笑我太疯癫本人爱好颇多，既爱郭德纲又钟爱野生小说，看着别人的故事，构想着自己的未来。给各位看官看一篇野生作家大冰的文章——《旁人笑我太疯癫》，既可以朝九晚五，又可以浪迹天涯。感觉这话都成了现今每个90后的口头禅，小屁孩一样的年纪就整天叨叨着看破红尘，想追求另一种生活方式，确实欠抽。。。我不反对这样的人生观，但是至少我们可以把自己养活了再谈其他，就像本文的主人公一般… 结语世上最珍贵的事儿是什么？我想便是即将逝去或者已经失去的体验！]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travel-1]]></title>
    <url>%2F2017%2F08%2F27%2FTravel-1%2F</url>
    <content type="text"><![CDATA[前言作为一名90后有志青年、文艺青年，平常研究专业之余最大爱好便是各地“晃荡”了，尤其钟爱”独游”。好吧，实话说，因为目前是一只单身狗，没办法，只能独游… 在那个说话还不需要考虑后果的年纪，曾放出“要走遍中国”这样的豪言壮语，现在稍微有点理智了，觉得还是把生活的这一片区域”晃”完再说。。。目前居住在杭州，这个据传说支付宝、淘宝无处不在，同时又连个包子都买不起的城市。。。 另外，需要一提的是，本文图片存储于七牛云，认证方式有些坑，目前还在研究。友情提示，图片较大，加载耗时。。。Alibaba杭州有个阿里巴巴，这两天的福布斯富豪科技排行榜，Jack Ma评第七，Ma Huateng排第八，中国互联网被戏称已进入“马家时代”，作为全国、乃至全球知名企业，怎能不去一睹它的风采。拼着一把老骨头，骑了40分钟单车到了阿里巴巴西溪园区，又被称为淘宝城，据说是阿里巴巴总部所在地，进入园区需要内部邀请码，屌丝无法进入，索性绕着周边转了转，先放几张图，感受下：阿里北门，有一个巨大的logo，现场感受还是挺震撼的在阿里的北门附近Dream图标，感觉挺符合阿里的气氛，就随手把它拍了下来很多建筑中，南门必然很宽敞，同时配有Alibaba的logo阿里周边风景,大片草地，溪水从中穿过… 留下古道杭州城西的留下街道是一个千年古镇， 接余杭，多山林, 是一个典型的山乡集镇。留下街道原名西溪 , 据清光绪《钱塘县志》载 :” 宋建炎 3 年 (1129 年 )7 月， 高宗南渡 , 幸西溪 , 初欲建都于此 , 后得凤凰山 , 乃云 : ‘西溪且留下 ‘ 。故此处名留下 , 并一直沿用至今。 公交换乘走到了留下，烟雨蒙蒙，走进了这一片留下古街道，探访她独特的魅力不少老人住在这样的老屋之中，屋内挂着一幅毛主席画像，坐在躺椅上，抽着旱烟，看着门外的江南烟雨… 钱塘江钱塘江，古称浙，全名“浙江”，又名“折江”、“之江”、“罗刹江”，一般浙江富阳段称为富春江，浙江下游杭州段称为钱塘江。钱塘江最早见名于《山海经》，因流经古钱塘县（今杭州）而得名，是吴越文化的主要发源地之一。 钱塘江，连接着外海，一望无际，此处非钱塘江潮，所以不要误解。江上的铁桥，不时有火车和地铁从上边通过 结语生命无价，潮水无情。。。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js+express读取excel表格中的数据]]></title>
    <url>%2F2017%2F08%2F20%2FNode-js-express%E8%AF%BB%E5%8F%96excel%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[两周前看到一个excel表格，突然想了一个需求，能否将其中的数据通过某种语言读取出来？然后返回json格式的数据，渲染到html页面中？于是便开始了百度、谷歌的道路，最终选择利用Node.js这一门比较亲近的后台语言来实现，通过express来实现页面路由以及监听端口，利用node-xlsx这一包来实现读取 .xlsxexcel格式文件数据读取这一核心功能。 文件目录结构： node_modules 项目所依赖的包 website 项目静态资源目录，包含index.html和index2.html文件（配置路由返回不同页面） 01.xlsx excel表格，数据来源 index.js 实现读取、路由配置、监听端口等核心功能 package.json 项目配置文件 index.js文件：12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var xlsx = require(&quot;node-xlsx&quot;);var app = express();var xlsxData=xlsx.parse(&apos;01.xlsx&apos;);// 信息获取app.get(&apos;/messages&apos;,function(req,res)&#123; var str = JSON.stringify(xlsxData); // charset=utf-8 解决json数据中中文乱码 res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot; &#125;); res.end(str);&#125;)//对静态文件做处理app.use(express.static(__dirname+&apos;/website&apos;));app.get(&apos;/&apos;,function(req,res)&#123; res.sendFile(__dirname+&apos;/website/index.html&apos;);&#125;)app.get(&apos;/admin&apos;,function(req,res)&#123; res.sendFile(__dirname + &apos;/website/index2.html&apos;);&#125;)app.listen(1000,function()&#123; console.log(&apos;监听1000端口成功！&apos;);&#125;) 核心思想：在本项目中，引入开发所依赖的包文件，通过’/messages’的方法来获取并返回excel中的数据，’/‘方法返回index.html静态文件，在该文件中利用ajax方法，获取接口为’/messages’的数据，’/admin’来获取另一静态页面index2.html；最后本项目通过监听listen 1000端口来启动本地服务器。 index.html文件：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;学校&lt;/th&gt; &lt;th&gt;系别&lt;/th&gt; &lt;th&gt;专业&lt;/th&gt; &lt;th&gt;类别&lt;/th&gt; &lt;th&gt;年级&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; $.ajax(&#123; url:&apos;/messages&apos;, dataType:&apos;json&apos; &#125;).done(function(result)&#123; // 渲染页面 //表格名称 $(&apos;caption&apos;).text(&apos;&apos;+result[0].name+&apos;&apos;); //表格内容 $.each(result[0].data,function(i,v)&#123; console.log(i,v); $(&apos;&lt;tr&gt;&lt;/tr&gt;&lt;th scope=&quot;row&quot;&gt;&apos;+(i+1)+&apos;&lt;/th&gt;&lt;td&gt;&apos;+v[0]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[1]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[2]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[3]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[4]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[5]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[6]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[7]+&apos;&lt;/td&gt;&lt;td&gt;&apos;+v[8]+&apos;&lt;/td&gt;&lt;/tr&gt;&apos;).appendTo($(&apos;tbody&apos;)); &#125;) &#125;) &#125;)&lt;/script&gt; 核心思想：该文件中有表格的基本结构，通过ajax调用’/messages’接口来获取json格式的数据，并将返回的数据遍历渲染到html页面中 启动项目运行index.js文件监听端口来启动本项目 node index.js localhost:1000 最终效果图： 参考文章]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站SEO优化]]></title>
    <url>%2F2017%2F08%2F17%2F%E7%BD%91%E7%AB%99SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[这几天做的项目模块中涉及到了对公司网站的SEO优化，之前对网站的优化也一知半解，仅仅停留在使用合理化标签、减少代码的冗余量、网站标题、描述词优化这些基础水平。但在真实项目环境中，网站优化所涉及的内容很多，是一项足够考验耐力和细致的脑力劳动。 什么是SEO？搜索引擎优化(Search Engine Optimization,简称SEO)是一种利用搜索引擎的搜索规则来提高有关目标网站在有关搜索引擎的排名方式。 对搜索引擎不友好的网站有哪些特征： 网页中大量采用图片或者 Flash 等富媒体（Rich Media）形式，没有可以检索的文本信息，而 SEO 最基本的就是文章 SEO 和图片 SEO； 网页没有标题，或者标题中没有包含有效的关键词； 网页正文中有效关键词比较少（一般小于整文章 2%~8%）； 网站导航系统让搜索引擎“看不懂”； 大量动态网页让搜索引擎无法检索； 没有被其他已经被搜索引擎收录的网站提供的链接； 网站中充斥大量欺骗搜索引擎的垃圾信息，如“过渡页”、“桥页”、颜色与背景色相同的文字； 网站中缺少原创的内容，完全照搬硬抄别人的内容等。 搜索引擎优化内部优化META 标签优化：例如：TITLE，KEYWORDS，DESCRIPTION 等的优化内部链接的优化，包括相关性链接（Tag 标签），锚文本链接，各导航链接，及图片链接网站内容更新：每天保持站内的更新(主要是文章的更新等) 外部优化外部链接类别：博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、相关信息网等尽量保持链接的多样性外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。外链选择：与一些和你网站相关性比较高,整体质量比较好的网站交换友情链接,巩固稳定关键词排名 SEO优化步骤关键词分析（也叫关键词定位）这是进行SEO优化最重要的一环，关键词分析包括：关键词关注量分析、竞争对手分析、关键词和网站相关性分析、关键词布置、关键词排名预测。 网站架构分析网站结构符合搜索引擎的爬虫喜好则有利于SEO优化。网站架构分析包括：剔除网站架构不良设计、实现树状目录结构、网站导航与链接优化。 网站目录与页面优化SEO不只是让网站首页在搜索引擎有好的排名，更重要的是让网站的每个页面都带来流量。 内容发布和链接设置搜索引擎喜欢有规律的网站内容更新，所以合理安排网站内容发布日程是SEO优化的重要技巧。链接布置会把整个网站有机地串联起来，让搜索引擎明白每个网页的重要性和关键词，实施的参考是第一点的关键词布置。友情链接战役也是这个时候展开。 与搜索引擎对话向各大搜索引擎登录入口提交尚未收录站点。在搜索引擎看SEO的效果，通过site:你的域名，知道站点的收录和更新情况。通过domain:你的域名或者link：你的域名，知道站点的反向链接情况。更好的实现与搜索引擎对话，建议采用Google网站管理员工具。 建立网站地图SiteMap根据自己的网站结构，制作网站地图，让你的网站对搜索引擎更加友好化。让搜索引擎能通过SiteMap就可以访问整个站点上的所有网页和栏目。最好有两套 siteMap,一套用户方便客户快速查找站点信息（html 格式），另一套方便搜索引擎得知网站的更新频率、更新时间、页面权重（xml 格式）。所建立的 sitemap 要和你网站的实际情况相符合。 高质量的友情链接建立高质量的友情链接，对于SEO优化来说，可以提高网站PR值以及网站的更新率，都是非常关键性的问题。 网站流量分析网站流量分析从 SEO 结果上指导下一步的 SEO 策略，同时对网站的用户体验优化也有指导意义。流量分析工具，建议采用分析工具 Google Analytics 分析工具和百度统计分析工具。 原文链接 参考文章]]></content>
      <tags>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack简介与使用二]]></title>
    <url>%2F2017%2F08%2F14%2Fwebpack%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言之前总结了一篇文章，简单介绍了webpack及其相关知识点，但觉得有些地方还是不够详细，实践性不强，故而今天再次对其做个总结，争取一目了然。 webpack安装全局安装淘宝镜像：1npm install -g cnpm --registry=https://registry.npm.taobao.org 我们通过cnpm的方式来安装webpack，命令行执行：1cnpm install webpack -g 使用webpack接下来我们通过一个简单的例子来演示使用webpack首先，创建一个index.html文件，如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;webpack demo&lt;/p&gt;&lt;/body&gt;&lt;script type=&apos;text/javascript&apos; src=&apos;bundle.js&apos;&gt;&lt;/script&gt;&lt;/html&gt; 说明：这里bundle.js就是我们打包以后得到的js文件。然后再创建一个js文件，命名为entry.js,这个问津通常通过webpack打包为bundle.js。如下：1document.write(&apos;this is a demo which show how to use webpack&apos;); 至此我们的目录有两个文件entry.js和index.html。下面通过webpack将js文件打包。执行下面命令行：webpack ./entry.js bundle.js如果没有出错的话，目录中就会生成了bundle.js文件，是打包以后的文件。现在，在浏览器中打开index.html,可以看出页面中显示了this is a demo which show how to use webpack。目前前端开发中，我们通常采用的是组件化开发方式，这样就会对应很多歌js文件，而打包工具的出现则是为了正确处理这些js文件的依赖关系，并生成一个最终的文件，这样，我们最后只需要加载打包以后的文件就可以了，而无需加载许多danger的js文件。接下来我们就试着下多个js文件的打包。新建一个content.js文件，文件内容如下：1document.write(&apos;this is content&apos;); 将entry.js文件修改如下：1document.write(require(&apos;./content.js&apos;)); 打包，执行webpack ./entry.js bundle.js刷新index.html页面，可以看到此时其内容已变成this is content可以看到，webpack以entry.js文件为入口，而entry.js文件又依赖了content.js,这时webpack就会去加载content.js最生成bundle.js 使用loader上面的例子中可以看到webpack可以对js文件进行很好的处理，然而我们的项目中通常需要用到一些css文件对样式进行调整。那如何使用webpack对样式文件进行打包呢，就需要用上loader。我们首先需要将css文件以js模块的方式加载进来，然后将这些样式用到dom上。这两个过程对应两个加载器：css-loader和style-loader。这两个模块可以通过npm进行安装，注意安装到当前的目录即可，不要加-gnpm install css-loader style-loader举例：step1：新建一个css文件，style.css123body&#123; background:yellow&#125; step2:修改entry.js如下：12require(&apos;!style-loader!css-loader!./style.css&apos;);document.write(require(&apos;./content.js&apos;)); step3:打包webpack ./entry.js bundle.js刷新页面，可以看到背景变为黄色。!style-loader!css-loader!./style.css指对style.css文件先使用css-loader进行处理，再通过style-loader进行处理。css-loader将css文件进项处理，使其可以作为一个js modules被处理；style-loader则解析当前的样式，并应用到demo上。以上步骤略显繁杂，每次打包需要指定入口文件和生成文件，并且使用加载器时也需要手动配置，很不方便。为了解决这个问题我们可以使用配置文件来解决，配置文件其实就是说明让webpack来做什么的。 webpack.config.js这个文件设定了打包的配置，webpack会自动根据该文件来打包。一个基本的配置文件如下所示：123456789101112131415module.exports=&#123; entry:&apos;./entry.js&apos;, output:&#123; path:__dirname, filename:&apos;bundle.js&apos; &#125;, module:&#123; loaders:[ &#123; test:/\.css$/, loader:&quot;style-loader!css-loader&quot; &#125; ] &#125;&#125;; 这里指定了三个参数，包括entry，output，module，分别对应了入口文件entry.js,打包生成的文件bundle。js，以及模块加载器。有了配置文件，则可以直接打包：webpack dev serverwebpack还为我们提供了webpack-dev-server,它是一个小型的基于node的express服务利器。利用webpack-dev-server我们可以轻松地启动服务。且webpack-dev-server默认采用的是watch模式，也就是说它会自动监测文件的变化，并在页面做出实时的更新，我们不需要每次都重新编译。 安装webpack-dev-server为了方便子啊命令行中使用，同样全局安装。npm install webpack-dev-server -g 启动命令行：webpack-dev-server默认端口号为8080。在浏览器中打开http://localhost:8080/webpack-dev-server 可以看到index.html页面。修改content.js文件的内容，可以看到index.html页面文件自动刷新了。 关于webpack.config.js我们是以最简单的项目结构来演示，如下：myPro-css-src-dist-index.html-webpack.config.js这样我们的项目结构就很清晰了。css文件夹中存放样式文件，src文件中存放js文件，node_modules中是我们用到的各种包，dist文件存放打包生成的文件。现在做一下两点：1、css使用less编写2、打包文件到dist目录下第一步：在css文件夹中创建以下两个文件index.less1@import &apos;demo.less&apos;; demo.less:12345678body&#123; background:yellow; .main&#123; width:200px; height:200px; border:10px solid red; &#125;&#125; 第二步，在src文件夹中：content.js:1module.exports=&apos;it is from content.js&apos;; enrty.js:123require(&apos;../css/index.less&apos;);let content=require(&apos;./content.js&apos;);alert(content); 第三部：修改index.html12345678910111213&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;webpack demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot; id=&quot;main&quot;&gt; &lt;p&gt;webpack demo&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 配置less-loader需要安装less-loader,而less-loader依赖于less，因此需要安装：npm install less-loader less然后再config文件中配置对less文件的处理，如下：123456789101112module: &#123; loaders: [ &#123; test: /\.css$/, loader: &quot;style!css&quot; &#125;, &#123; test: /\.less$/, loader: &quot;style-loader!css-loader!less-loader&quot; &#125; ]&#125; 这里加入了对less文件的处理，需要注意loader的顺序，为style-loader！css-loader!less-loader意为先使用less加载器处理，解析为普通的css文件，再处理css文件，最后处理样式，类似于pipe的概念。 设置output在上篇文章中，我们提到了webpack.config.js文件中可以设置output，作为打包的出口参数。如下：1234output: &#123; path: __dirname, filename: &quot;bundle.js&quot;&#125; 这里设置了两项：path和filename这里我们希望将文件打包到dist目录下，则可以通过配置path来实现，完整配置如下：1234567891011121314151617181920let path = require(&apos;path&apos;);module.exports = &#123; entry: &quot;./src/entry.js&quot;, output: &#123; path: path.join( __dirname, &apos;/dist&apos;), //这里配置打包路径 filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &quot;style!css&quot; &#125;, &#123; test: /\.less$/, loader: &quot;style-loader!css-loader!less-loder&quot; &#125; ] &#125;&#125;; 执行：webpack 进一步了解webpack-dev-server上篇文章提到，webpack-dev-server为我们提供了一个小型的基于node的express服务器，使我们可以通过http://localhost:8080/webpack-dev-server/来访问页面，并且它可以监测文件的变化并在页面中实时显示出来。现在我们再来试下：启动webpack-dev-server访问http://localhost:8080/webpack-dev-server/修改content.js文件如下：可以看到，页面自动进行了刷新，但是alert的内容却没有变。这说明监测到了文件的变化，但是我们的index.html加载的js文件并没有变。那问题出在哪里？ webpack-dev-server原理webpack-dev-server通过sockjs实现实时变化监测，当文件变化时，服务器就会向客户端发送通知，客户端重新渲染。每次文件变化都会触发webpack-dev-server对文件进行重新编译，但是这个编译后的文件并不会每次都保存到我们的dist目录下，而是存放在内存中，默认情况下，这个文件的路径为当前路径。也就是说，每次文件变化后，内存中的bundle.js做出了实时的变化，而output中配置的文件其实并没有变。也就是说，如果我们在index.html中使用./bundle.js则能够实现页面内容的实时更新。那么，如何配置可以使其支持我们当前的写法./dist/bunlde.js呢？就需要用到publicPath这个属性。 output的publicPath属性webpack-dev-server默认支持文件路径为当前的路径，可以通过在output中配置publicPath属性对其进行更改，如下：123456789101112131415161718192021222324output: &#123; path: path.join( __dirname, &apos;/dist&apos;), publicPath: &apos;/dist/&apos;, filename: &quot;bundle.js&quot;&#125; ``` 这样设置我们就可以通过./dist/bundle.js路径访问到内存中的文件，在当前路径下已经存在同名文件的情况下，webpack-dev-server会优先使用内存中的文件。 至此，我们实现了： 1、使用less编写样式文件 2、将文件打包到指定目录 3、监测文件变化并实时展示 看到，现在我们还是采用的commonJS的规范来实现模块化， 而es6为我们提供了export和import语法来支持模块化，如果想要在项目中使用es6，同样可以通过webpack来配置实现。 ## webpack支持es6使webpack支持es6需要用到babel，它可以帮助我们将es6语法转化为es5的格式，首先，需要安装babel npm install babel-loader babel-core 安装babel-preset npm install babel-preset-es2015 然后，配置webpack.config.js，如下： ```javascript module: &#123; loaders: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot; &#125; ]&#125; 最后还需要加上babel的配置文件，在项目的根目录下创建文件.babelrc{ “presets”: [“es2015”] }这样，我们的webpack就支持通过es6的export和import实现模块化了。修改content.js内容如下：12var content = &apos;it is the origin content from content.js&apos;;export &#123;content&#125;; 修改entry.js内容如下：1234require(&apos;../css/index.less&apos;);import &#123;content&#125; from &apos;./content&apos;;let div = document.getElementById(&apos;main&apos;);div.innerHTML = content; 可以看到，我们现在通过es6的import和export实现js的模块化，打包：$ webpack 结语本篇文章转载于北方雪博客，原文地址]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA中自动压缩js,css文件]]></title>
    <url>%2F2017%2F08%2F09%2FIntelliJ-IDEA%E4%B8%AD%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9js-css%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近有个需求，要求使用IntelliJ IDEA编辑器时能够自动压缩js或者是css文件，于是乎就开始了百度、必应、谷歌。。。试了数不清的方法，结果发现还是没有用，最终在几个教程的综合之下加上一些运气，该功能得以实现。写个安装教程，争取别人看后能够一目了然。 使用此功能的前提是： 确保本机以及安装了NodeJS以及npm(具体安装方法不再阐述) intellij idea下以及安装了File Watchers插件(webstorm和intellij idea下如何自动编译sass和scss文件) 安装JavaScript压缩工具(以YUI Compressor为例)1npm i yuicompressor -g 点击：File - Settings - Tools - File Watchers进入相应目录 添加插件目录：值得注意的是在选择工具的安装目录的时候选择yuicompressor.cmd而非yuicompressor新建js文件，将会自动生成 相应文件名.min.js压缩文件 CSS压缩工具同JavaScript工具配置方法类似，可自行去研究使用结语在项目开发过程中，遇到各种各样的问题再正常不过，所幸我们不是一个人在战斗，在互联网这么发达的时代，有千千万万素昧平生的人可以是我们的老师，只要潜心研究，相信一定可以找到解决问题的方式。虽说遇到问题是好事，因为你可以从解决问题的过程中提升自我，当然我也保佑你不要所有的问题都让你遇到，这就过于恶心。还是适中一点较好。]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[px/em/rem的区别]]></title>
    <url>%2F2017%2F08%2F07%2Fpx-em-rem%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在移动端布局的过程中使用rem进行布局，一直以来的思路是浏览器监测屏幕宽度的大小，通过计算改变html中不同的font-size的值，来改变rem的相对值，但其实发现对其中的原理并不是很清楚，索性写篇文章做个整理，尽量将三者的关系区分开 有何区别？ px在缩放页面时无法调整哪些使用它作为单位的字体、按钮等的大小 em的值不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素的，也代表倍数 emem的使用是相对于其父级元素的大小的，即倍数。浏览器的默认字体高都是16px，未经调整的浏览器显示1em=16px.但是有一个问题，如果设置1.2em则变成19.2px，问题是px表示大小时会忽略掉小数位的(你想象不出来半个像素吧).而且1em=16px的关系并不好转，因此，常常人为的使1em = 10px.这里要借助字体的%来作为桥梁。 因为默认时字体16px = 100%,则有10px = 62.5%。所以首先在body中全局声明font-size=62.5%=10px,也就是定义了网页body默认字体大小为10px。由于em有继承父级元素大小的特性，如果某元素的父级没有设定字体大小，那么它就继承了body默认字体大小1em = 10px; 但是由于em是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用em分别给他们设置字体的大小往往要重新计算。比如说你在父级元素中声明了字体大小为1.2em,那么在声明子元素的字体大小时设置1em才能和父级元素内容大小一致，而不是1.2em(避免1.2*1.2=1.44em),因为此em非彼em。 example:1234&lt;span&gt;Outer &lt;span&gt;inner&lt;/span&gt; Outer&lt;/span&gt;body&#123;font-size:62.5%;&#125;span&#123;font-size:1.6em;&#125; 结果，外层为body字体10px的1.6倍=16px,内层字体为外层内容字体16px的1.6倍25px(或26px，不同浏览器取舍小数不同)。 明显的，内部内的文字受到了外父级元素的影响。基于这点，在实际中给我们的计算带来了很大的不方便。 remrem的出现再也不用担心还要根据父级元素的font-size计算em的值了，因为它始终是基于根元素()的。 比如默认的html font-size:16px,那么想要设置12px文字就是：12/16 = 0.75rem; 1234html&#123;font-size:62.5%;&#125; (16px -&gt; 100% 1rem -&gt; 10px -&gt; 62.5%)span&#123;font-size:16px;font-size:1.6rem;&#125; 结果：内外的的字体大小均为16px; 想要注意的是，为了兼容不支持rem的浏览器，我们需要在各个使用了rem地方前面写上对应px的值，这样不支持的浏览器可以优雅降级。 最后，选择什么样的字体单位由你的项目来决定，如果你的用户群都使用最新的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px，或者两者同时使用。]]></content>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java模板引擎FreeMarker]]></title>
    <url>%2F2017%2F08%2F01%2FJava%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreeMarker%2F</url>
    <content type="text"><![CDATA[什么是FreeMarker?FreeMarker是一款模板引擎：即一种基于模板、用来生成输出文本(任何来自于HTML格式的文本用来自动生成源代码)的通用工具。它是为Java程序员提供的一个开发包，或者说是一个类库。他不是面向最终用户的，而是为程序员提供的一款可以嵌入他们所开发铲平的应用程序。 FreeMarker是一款模板引擎FreeMarker不是web框架 FreeMarker官网 前端设计师和程序员的学习侧重点MVC设计(Model、View、Controller)前端设计师侧重于View(模板设计)程序员全面掌握MVC 学习心得：先规划一个范围；再指定一个目标；创建可行性计划；边玩边学 如何开始？Freemarker原理: maven构建FreeMarker项目123Maven构建Spring+Freemarker项目配置文件介绍运行小例：列表展示 Maven构建Spring+Freemarker项目123Eclipse+Maven使用简介Maven依赖Spring和Freemarker的jar包Spring配置文件和Freemarker Servlet配置文件 配置文件介绍：12Spring配置文件applicationContext.xmlSpring Freemarker Servlet配置文件spring-servlet.xml maven构建freemarker项目代码实战使用springboot来进行项目搭建，同时，项目基于javaconfig进行配置。整体目录结构如下：项目POM文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zccoder&lt;/groupId&gt; &lt;artifactId&gt;myfreemarker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 用于数据持久化 --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt;&lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置FreeMarker:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.myimooc.myfreemarker.config;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer;import org.springframework.web.servlet.view.freemarker.FreeMarkerView;import org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver;import com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import com.myimooc.myfreemarker.web.controller.RoleDirectiveModel;/** * Web项目SpringMvc配置 * @author ZhangCheng * @date 2017-03-19 * @version V1.0 */@Configuration@EnableWebMvc@ComponentScan(&quot;com.myimooc.myfreemarker&quot;)public class SpringMvcConfig extends WebMvcConfigurerAdapter&#123; /** * 配置视图解析器 * @return */ @Bean public FreeMarkerViewResolver getFreeMarkerViewResolver()&#123; FreeMarkerViewResolver freeMarkerViewResolver = new FreeMarkerViewResolver(); freeMarkerViewResolver.setOrder(1); freeMarkerViewResolver.setSuffix(&quot;.html&quot;); freeMarkerViewResolver.setCache(false); freeMarkerViewResolver.setRequestContextAttribute(&quot;request&quot;); freeMarkerViewResolver.setContentType(&quot;text/html;charset=utf-8&quot;); freeMarkerViewResolver.setViewClass(FreeMarkerView.class); return freeMarkerViewResolver; &#125; /** * 配置静态资源映射 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); &#125; /** * 配置FASTJSON * @return */ @Bean public FastJsonHttpMessageConverter fastJsonHttpMessageConverters() &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.QuoteFieldNames); fastJsonConfig.setCharset(Charset.forName(&quot;UTF-8&quot;)); fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;MediaType&gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); fastConverter.setSupportedMediaTypes(supportedMediaTypes); fastConverter.setFastJsonConfig(fastJsonConfig); return fastConverter; &#125; /** * 配置FreeMarker * @return */ @Bean public FreeMarkerConfigurer getFreeMarkerConfigurer()&#123; FreeMarkerConfigurer freeMarkerConfigurer = new FreeMarkerConfigurer(); freeMarkerConfigurer.setDefaultEncoding(&quot;UTF-8&quot;); freeMarkerConfigurer.setTemplateLoaderPath(&quot;classpath:/templates/&quot;); Properties settings = new Properties(); settings.setProperty(&quot;template_update_delay&quot;, &quot;5&quot;); settings.setProperty(&quot;url_escaping_charset&quot;, &quot;UTF-8&quot;); settings.setProperty(&quot;defaultEncoding&quot;, &quot;UTF-8&quot;); settings.setProperty(&quot;whitespace_stripping&quot;, &quot;true&quot;); settings.setProperty(&quot;boolean_format&quot;, &quot;true,false&quot;); settings.setProperty(&quot;number_format&quot;, &quot;0.##########&quot;); settings.setProperty(&quot;locale&quot;, &quot;zh_CN&quot;); settings.setProperty(&quot;datetime_format&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;); settings.setProperty(&quot;date_format&quot;, &quot;yyyy-MM-dd&quot;); settings.setProperty(&quot;time_format&quot;, &quot;HH:mm:ss&quot;); settings.setProperty(&quot;tag_syntax&quot;, &quot;square_bracket&quot;); settings.setProperty(&quot;classic_compatible&quot;, &quot;true&quot;); settings.setProperty(&quot;template_exception_handler&quot;, &quot;ignore&quot;); settings.setProperty(&quot;auto_import&quot;, &quot;/spring.ftl as spring, /common/spring.ftl as spring&quot;); freeMarkerConfigurer.setFreemarkerSettings(settings); // 配置自定义指令 Map&lt;String,Object&gt; variables = new HashMap&lt;String,Object&gt;(); variables.put(&quot;role&quot;, new RoleDirectiveModel()); freeMarkerConfigurer.setFreemarkerVariables(variables); return freeMarkerConfigurer; &#125; /** * 配置JSON解析器 */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super.configureMessageConverters(converters); converters.add(this.fastJsonHttpMessageConverters()); &#125;&#125; 配置Web,类似于web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.myimooc.myfreemarker.config;import java.util.EnumSet;import javax.servlet.DispatcherType;import javax.servlet.FilterRegistration;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletRegistration;import org.springframework.context.annotation.Configuration;import org.springframework.web.WebApplicationInitializer;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.filter.CharacterEncodingFilter;import org.springframework.web.servlet.DispatcherServlet;/** * Web项目启动类 * * @author ZhangCheng * @date 2017-03-19 * @version V1.0 * */@Configurationpublic class WebConfig implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(SpringMvcConfig.class); // 新建WebApplication，注册配置类，并将其和当前servletContext关联。 context.setServletContext(servletContext); // 注册SpringMVC的DispatcherServlet。 ServletRegistration.Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(context)); servlet.addMapping(&quot;/&quot;); servlet.setLoadOnStartup(1); // 注册SpringMVC的字符过滤器 FilterRegistration.Dynamic encodingFilter = servletContext.addFilter(&quot;encoding&quot;, new CharacterEncodingFilter()); EnumSet&lt;DispatcherType&gt; dispatcherTypes = EnumSet.allOf(DispatcherType.class); dispatcherTypes.add(DispatcherType.REQUEST); dispatcherTypes.add(DispatcherType.FORWARD); encodingFilter.addMappingForUrlPatterns(dispatcherTypes, true, &quot;*&quot;); encodingFilter.setInitParameter(&quot;encoding&quot;, &quot;UTF-8&quot;); &#125;&#125; 新建模板页面边写控制器启动项目： 小例子：列表demo展示 编写控制器：编写FreeMarker:1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;$&#123;username&#125;&lt;/h1&gt;&lt;ul&gt; [#list userList as item] &lt;li&gt;$&#123;item.name&#125;的生日是：$&#123;item.birthday?string(&apos;yyyy-MM-dd&apos;)&#125;&lt;/li&gt; [/#list]&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 补充：springboot集成FreeMarker输入网址： start.spring.io 基础技能FreeMarker取值章节简介本节要点：123Java中常用的数据模型取值（插值）指令逻辑指令：if、switch Java数据模型、freemarker取值Java中常用的数据模型123基本类型数据（比如integer）封装的对象类型(比如User对象)集合类型：List、Map 取值指令123456常用$&#123;var&#125;语法进行取值对null、不存在对象取值$&#123;var!&#125;对包装对象的值，通过“点”语法：$&#123;User.name&#125;取值的时候进行计算、赋值Date类型格式$&#123;date?string(&apos;yyyy-MM-dd&apos;)&#125;如何转义HTML内容：$&#123;var?html&#125; FreeMarker取java基本数据模型的值控制器页面层效果图 boolean类型值的format布尔值：${booleanVar?string(‘yes’,’no’)} date类型值的format日期：${dateVar?string(‘yyyy-MM-dd’)} null或者不存在的变量取值null:${nullVar!’我是默认值’}missing:${ssssVar!’我是默认值’} 技能进阶变量的定义、赋值、运算边写代码：12345678&lt;h2&gt;2.赋值运算&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;赋值&amp;运算&lt;/li&gt; [#assign a=100] a = $&#123;a&#125; &lt;br/&gt; a+100=$&#123;a+100&#125;&lt;/ul&gt; 效果如下： 自定义对象User变量的取值1234567&lt;h2&gt;3.封装类型&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;对象&lt;/li&gt; $&#123;(userObj.name)!&quot;默认值&quot;&#125; &lt;li&gt;富文本&lt;/li&gt; $&#123;(briefVar)!?html&#125;&lt;/ul&gt; 集合List的遍历语法：123[#list listName as item] &lt;font color=&quot;red&quot;&gt;$&#123;item!&#125;&lt;/font&gt;&lt;br/&gt;[/#list] 集合Map的遍历语法：123[#list map?keys as key] &lt;font color=&quot;red&quot;&gt;$&#123;key&#125;:$&#123;map[key]!&#125;&lt;/font&gt;&lt;br/&gt;[/#list] if语法语法：1234567&lt;li&gt;if else&lt;/li&gt;[#assign var = 100/][#if var == 99] &lt;font color=&quot;red&quot;&gt;var = 99&lt;/font&gt;&lt;br/&gt;[#else] &lt;font color=&quot;red&quot;&gt;var != 99&lt;/font&gt;&lt;br/&gt;[/#if] 判断某个对象或值是否存在12345[#if myList?exists][/#if]或[#if myList??][/#if] switch语法语法：12345678910111213&lt;li&gt;switch case break default&lt;/li&gt;[#assign var3 = 10 /][#switch var3][#case 10] 10&lt;br/&gt; [#break][#case 100] 100&lt;br/&gt; [#break][#default] other[/#switch] 高级技巧自定义函数介绍补充表达式指令：12+ ：字符串连接，集合连接[index]:下标取值 自定义函数12自定义排序函数实现templateMethodModelEx接口 自定义接口1实现TemplateDirectiveModel接口 string基本操作指令代码：12345678910111213141516171819202122232425262728&lt;h2&gt;6.字符操作&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;字符串常用内建函数-连接&lt;/li&gt; [#assign stra=&apos;hello&apos;/] [#assign strb=&apos;world&apos;/] &lt;font color=&quot;red&quot;&gt;$&#123;stra + strb&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-截取&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?substring(5,8)&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-长度&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?length&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-大写&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?upper_case&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-小写&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?lower_case&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-index_of&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?index_of(&apos;w&apos;)&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-last_index_of&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?last_index_of(&apos;o&apos;)&#125;&lt;/font&gt;&lt;br/&gt; &lt;li&gt;字符串常用内建函数-replace&lt;/li&gt; &lt;font color=&quot;red&quot;&gt;$&#123;(stra + strb)?replace(&apos;o&apos;,&apos;xx&apos;)&#125;&lt;/font&gt;&lt;br/&gt;&lt;/ul&gt; 效果图： 自定义函数步骤一：边写自定义函数类 步骤二：再返回的控制器里面，添加自定义函数类，并指定方法名 步骤三：在页面使用排序方法1234567891011&lt;li&gt;整数排序sort_int&lt;/li&gt;[#assign mylistinfo=[2,3,4,1,5,6,9]/]&lt;li&gt;未排序&lt;/li&gt;&lt;#list mylistinfo as item&gt; $&#123;item&#125;&lt;/#list&gt;[#assign mylistinfo=[2,3,4,1,5,6,9]/]&lt;li&gt;排序&lt;/li&gt;&lt;#list sort_int(mylistinfo) as item&gt; $&#123;item&#125;&lt;/#list&gt; 步骤四：验证输出 list排序内建函数、常用指令使用内建函数进行排序，item_index为下标，默认为升序123&lt;#list mylistinfo?sort as item&gt; $&#123;item_index&#125;:$&#123;item&#125;&lt;/#list&gt; 使用内建函数进行排序，降序123&lt;#list mylistinfo?sort?reverse as item&gt; $&#123;item_index&#125;:$&#123;item&#125;&lt;/#list&gt; 其它常用内建函数1234&lt;li&gt;List长度&lt;/li&gt;$&#123;mylistinfo?size&#125;&lt;li&gt;List下标取值&lt;/li&gt;$&#123;mylistinfo[3]&#125; 效果图： 自定义指令页面使用自定义指令123456789101112&lt;h2&gt;8.自定义指令&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;用户123456是否拥有admin角色，并且返回admin权限&lt;/li&gt; [@role user=&apos;123456&apos; role=&apos;admin&apos;;result1,result2] [#if result1] 我的角色是&lt;font color=&quot;red&quot;&gt;admin&lt;/font&gt; [/#if] &lt;#list result2 as item&gt; $&#123;item&#125; &lt;/#list&gt; [/@role]&lt;/ul&gt; 验证输出： FreeMarker内建函数代码1234567891011121314151617181920212223242526272829303132333435363738&lt;h1&gt;freemarker内建函数&lt;/h1&gt; &lt;h2&gt;1.字符串内建函数&lt;/h2&gt; &lt;ul&gt; &lt;#list &quot;a|b|c|d&quot;?split(&quot;|&quot;) as item&gt; &lt;li&gt;$&#123;item&#125;&lt;/li&gt; &lt;/#list&gt; &lt;!-- 字符串转日期 --&gt; [#assign var1=&quot;01/03/2017&quot;?date(&quot;MM/dd/yyyy&quot;)] [#assign var2=&quot;23:45:30&quot;?time(&quot;HH:mm:ss&quot;)] [#assign var2=&quot;2016-12-31 03:05 PM&quot;?datetime(&quot;yyyy-MM-dd hh:mm&quot;)] &lt;li&gt;$&#123;var1&#125;&lt;/li&gt; &lt;li&gt;$&#123;var2&#125;&lt;/li&gt; &lt;li&gt;$&#123;var3&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;2.数字类型内建函数&lt;/h2&gt; &lt;ul&gt; [#assign numVar1 = 314.46565/] &lt;li&gt;$&#123;numVar1?string(&quot;0.##&quot;)&#125;&lt;/li&gt; &lt;li&gt;$&#123;numVar1?round&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;3.list内建函数&lt;/h2&gt; &lt;ul&gt; [#assign listVar1 = [1,2,3,4,54,57,87,96]/] &lt;li&gt;$&#123;listVar1?chunk(4)?size&#125;&lt;/li&gt; &lt;#list listVar1?chunk(4)?last as item&gt; &lt;li&gt;$&#123;item&#125;&lt;/li&gt; &lt;/#list&gt; &lt;/ul&gt; &lt;h2&gt;4.其它内建函数&lt;/h2&gt; &lt;ul&gt; [#assign sVar1 = &apos;hello&apos;/] &lt;li&gt;$&#123;sVar1?is_number?string(&apos;yes&apos;,&apos;no&apos;)&#125;&lt;/li&gt; &lt;li&gt;$&#123;sVar1?has_content?string(&apos;yes&apos;,&apos;no&apos;)&#125;&lt;/li&gt; &lt;li&gt;$&#123;sVar2!&quot;ss&quot;&#125;&lt;/li&gt; &lt;li&gt;$&#123;(&quot;1+2&quot;)?eval&#125;&lt;/li&gt; &lt;li&gt;$&#123;&quot;1&quot;+&quot;2&quot;?is_string?string(&apos;yes&apos;,&apos;no&apos;)&#125;&lt;/li&gt; &lt;/ul&gt; 效果图如下： macro、function指令macro、nested、return 123macro语法[@macro_name param /] 调用macronested语法 总结]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局语法及示例]]></title>
    <url>%2F2017%2F07%2F29%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[背景网页布局(layout)是css的一个重要应用布局的传统解决方案，基于盒装模型，依赖display+position+float属性。对于特殊布局，如垂直居中就不容易实现。 发展2009年，W3C提出了一种新的方案—Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，我们可以安全的使用这项功能。flex布局将成为未来布局的首选方案，flex布局示例请参考: Flex布局示例 语法Flex布局是什么？Flex是 Flexible Box的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局123.box&#123; display:flex;&#125; 行内元素也可以使用flex布局123.box&#123; display:inline-block;&#125; Webkit内核的浏览器，必须加上-webkit前缀1234.box&#123; display:-webkit-flex; /* Safari */ display:flex;&#125; 注意：设为Flex布局之后，子元素的float、clear和vertical-align属性将消失 基本概念采用Flex布局的元素，称为Flex容器(flex container)，简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目(flex item),简称”项目”。容器默认存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，交叉轴的结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫main size，占据的交叉轴空间叫做cross size。 容器的属性6个属性设置在容器上 flex-direction（决定主轴的方向 即项目的排列方向） flex-wrap（项目如果在一条轴线上排不下将如何换行） flex-flow（flex-direction和flex-wrap的简写形式） justify-content（项目在主轴上的对齐方式） align-items（项目在交叉轴上的对齐方式） align-content（定义了多根轴线的对齐方式） flex-direction属性flex-direction属性决定主轴的方向(即项目的排列方向)123.box&#123; flex-direction:row | row-reverse | column | column-reverse;&#125; 它有四个值： row(默认值)：主轴为水平方向，起点在左端 row-reverse: 主轴为水平方向，起点在右端 column: 主轴为垂直方向，起点在上端 column-reverse: 主轴为垂直方向，起点在下端 flex-wrap属性默认情况下，项目都排列在一条轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它取三个值： nowrap(默认值)：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow属性flex-flow属性是flex-direction和flex-wrap属性的简写形式，默认值为row nowrap123.box&#123; flew-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它有5个值，具体对齐方式与轴的方向有关。（假设主轴为从左向右） flex-start(默认值)：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义了项目在交叉轴上如何对齐123.box&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体对齐方式与交叉轴的方向有关，假设交叉轴从上到下 flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch(默认值)：如果项目为设高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根属性，则该属性不起作用。123.box&#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可取6个值： flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch(默认值)：轴线占满整个交叉轴 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0123.item&#123; order:&lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item&#123; flex-grow:&lt;number&gt;; /*default 0*/&#125; 如果所有的flex-grow属性值都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小123.item&#123; flex-shrink:&lt;number&gt;; /*default 1*/&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性值为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间(main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。123.item&#123; flex-basis:&lt;length&gt; | auto; /*default auto*/&#125; 它可以设为跟width或height一样的值（比如350px）,则项目将占据固定空间。 flex属性flex属性是flex-grow,flex-shrink和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item&#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto)和none(0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item&#123; align-self:auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可取6个值，除了auto,其他都与align-items属性值完全一致。 The end!practice more]]></content>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack简介与使用]]></title>
    <url>%2F2017%2F07%2F27%2FWebpack%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言CommonJS和AMD事用于JavaScript模块管理的两大规范，前者定义的是模块的同步加载，主要用于NodeJS;而后者则是异步加载，通过RequireJS等工具适用于前端。随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者自身就会发布到npm平台。因此，让前端项目更方便的使用npm上的资源成为一大需求。 Webpack介绍webpack是一个module bundle（模块打包工具），在webpack里，所有类型的文件都可以是模块，包括我们最常见的JavaScript、及CSS文件、图片、json文件等等。通过webpack的各种加载器，可以更高效的管理这些文件，官方介绍如下： Webpack和Gulp的区别 Gulp出现的比较早，更适合于做任务型的，可以处理任何的网站静态网站、SPA、Node.js项目代码，Gulp里面就是一堆的任务；Webpack一般全部用来处理SPA应用，就React、Vue.js、AngularJS使用 Webpack官方文档官方地址：https://webpack.js.org/concepts/ Webpack的优势 对CommonJS、AMD、ES6的语法做了兼容 对js、CSS、图片等资源文件都支持打包 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持有独立的配置文件webpack.config.js可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间，等 Webpack的使用新建项目在项目的根目录下运行：npm init -ysrc目录是项目的开发文件，dist是打包后的文件 安装123npm install webpack -g //全局安装npm install webpack -save-dev //在当前目录下安装npm install react -save //安装react项目 配置文件 webpack.config.js 12345678910111213//webpack的开发配置文件//边写配置文件，要有最基本的文件入口和输出文件配置信息//还可添加loader和各种插件配置使用var path=require(&apos;path&apos;);module.exports = &#123; //单页面的SPA的入口文件 entry:path.resolve(__dirname,&apos;src/js/app.js&apos;), //构建之后的文件输出位置配置 output:&#123; path: path.resolve(__dirname,&apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125;; 运行webpack --config webpack.config.js Webpack实现启动的更好方式我们可以通过设置webpack-dev-server来设置启动Webpack除了提供模块打包功能，还提供了一个基于Node.js Express框架的开发服务器，它是一个静态资源Web服务器，对于简单静态页面或者仅依赖于独立服务器的前端页面，都可以直接使用这个开发服务器进行开发。在开发过程中，开发服务器会监听每一个文件的变化，进行实时打包，并且可以推送通知前端页面代码发生了变化，从而可以实现页面的自动刷新。 更好的方式实现自动启动，webpack官方提供了一个第三个插件，自动监听代码变化，帮我们重新构建，把webpack和express封装了 npm install webpack-dev-server -save-dev 调整npm的package.json script部分中开发命令的配置12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;develop&quot;: &quot;webpack-dev-server --config webpack.config.js --devtool eval --progress --colors --hot --content-base src&quot;, &quot;publish&quot;: &quot;webpack --config webpack.publish.config.js&quot; &#125; webpack-dev-server 在localhost:8080建立一个Web服务器–devtool eval 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号–progress显示合并代码进度–colors –hot,命令行中显示颜色！–content-base指向设置的输出目录 在demo目录下新家一个index.html文件，文件目录结构如图所示： 1234567891011&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;webpack 使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 执行npm run develop将会启动监听，并在8080端口开启一个服务器 如果修改了app.js文件，会自动执行构建，刷新浏览器会发生变化 总的来说，当你运行npm run develop的时候，会启动一个Web服务器，然后监听文件修改，然后自动重新合并你的代码。 Webpack常用加载器Loader：这是webpack准备的一些预处理工具在构建项目之前做一些预处理操作，比如ES6转ES5，Sass、Less 编译JSX和ES6到ES5语法的加载器安装：12npm install babel-loader --save-devnpm install babel-core babel-preset-es2015 babel-preset-react --save-dev babel-loader:转换器，编译JSX语法和ES6语法到ES5语法修改开发配置环境：webpack.config.js1234567891011module: &#123; loaders: [ &#123; test: /\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: &apos;babel&apos;, // 加载模块 &quot;babel&quot; 是 &quot;babel-loader&quot; 的缩写 query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125; ] &#125; 加载CSSwebpack允许像加载任何代码一样加载css。可以选择需要的方式，但是可以为每个组件把所有CSS加载到入口主文件中来做任何事情加载CSS需要css-loader和style-loader，他们做不同的两件事情 css-loader会遍历css文件，然后找到url()表达式然后处理他们，style-loader会把原来的CSS代码插入页面中的一个style标签中 安装 npm install css-loader style-loader --save-dev修改配置文件：12345// 可以在 js 中引用 css 的加载器&#123; test: /\.css$/, loader: &apos;style!css&apos; // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左&#125; !用来定义loader的串联关系，”-loader”可以省略不写，多个loader之间用”!”连接起来 加载Sass下载依赖 npm install sass-loader -save-dev修改配置文件：12345// 可以在 js 中引用 sass 的加载器&#123; test: /\.scss$/, loader: &apos;style!css!sass&apos;&#125; 安装sass-loader之后运行 npm run develop时报错解决方式：npm install node-sass -save-dev 图片处理下载依赖 npm install url-loader file-loader --save-dev修改配置文件：123456789&#123; test: /\.(png|jpg|gif|jpeg)$/, loader: &apos;url?limit=25000&apos; &#125;, // 处理字体 &#123; test: /\.(eot|woff|ttf|woff2|svg)$/, loader: &apos;url?limit=25000&apos; &#125; 加载器会把需要转换的路径变成BASE64字符串，把CSS中的”url()”像其他require或者import来处理.意味着我们可以通过它来处理我们的图片文件。url-loader传入的limit参数是告诉它图片如果不大于25KB的话要自动在它从属的css文件中转成BASE64字符串]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[front-end developers interview]]></title>
    <url>%2F2017%2F07%2F24%2Ffront-end-developers-interview%2F</url>
    <content type="text"><![CDATA[1.CSS盒模型包含哪些元素:content(内容) 、padding(填充) 、border(边框) 、margin(边界) 2.写出你知道的清除浮动的方法方法一：使用带有clear属性的空元素12345在浮动元素后添加一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;.clear&#123; clear:both;&#125;亦可使用&lt;hr class=&quot;clear&quot;/&gt;或&lt;br class=&quot;clear&quot;/&gt;来清理 方法二：使用CSS的:after伪元素1234567891011&lt;div class=&quot;container clearfix&quot;&gt;&lt;/div&gt;.clearfix:after&#123; content:&quot;&quot;; display:block; height:0; clear:both;&#125;为了考虑到IE6/IE7浏览器，可以给clearfix添加zoom:1;.clearfix&#123; zoom:1;&#125; 方法三：使用css的overflow:hidden;属性进行处理给浮动元素的容器添加overflow:hidden;或overflow:auto;可以怪异清理浮动1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;floatleft&quot;&gt;&lt;/div&gt; &lt;div class=&quot;floatright&quot;&gt;&lt;/div&gt;&lt;/div&gt;.container&#123; overflow:hidden;&#125;.container&#123; overflow:auto;&#125; 方法四：给浮动元素的容器添加浮动给浮动元素的容器添加浮动属性即可清理内部浮动,使用方便但是会对文档造成影响1234567&lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;floatleft&quot;&gt;&lt;/li&gt; &lt;li class=&quot;floatright&quot;&gt;&lt;/li&gt;&lt;/ul&gt;.menu&#123; float:left;&#125; 方法五：使用邻接元素清理给浮动元素后边的元素添加clear属性12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;floatleft&quot;&gt; &lt;div class=&quot;floatright&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;.content&#123; clear:both;&#125; 确保的是content元素和floatleft、floatright元素在同一个父元素内方法六：使用display:table使用display:table模拟表格布局也可解决浮动问题，并可以自动对齐高度。但是table存在一系列问题，建议不使用。 3.CSS选择器的优先级!important &gt; 行内样式 &gt; 后代、交叉 &gt; ID &gt; class &gt; 标签选择器 &gt; * &gt;浏览器预定义样式 &gt; 继承样式 4.让子块元素相对于父元素居中1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;方法一：.parent&#123; text-align:center;&#125;.child&#123; display:inline-block;&#125;方法二：.child&#123; margin:0 auto;&#125; 5.说下opacity:0,visibility:hidden,display:none的区别opacity:0;该元素被隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件，那么点击该区域，也能触发点击事件的.visibility:hidden;该元素被隐藏起来了，但是不会改变页面布局，但是不会触发该元素已经绑定的事件display:none;把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉一样 6.微信HTML5页面制作1.H5页面正规流程下需要用什么软件制作（不要网上那种几张图片摆摆自动生成的）首先需要澄清一下，H5页面，全称HTML5页面，指的其实是充分利用HTML5技术的网页。而网页，归根其实就是资源＋CSS＋HTML5+JAVASCRIPT代码，涉及到服务端请求的，还需要后端的支持，因此制作丰富精美的HTML5页面，如果细化一下你所说的正规流程：－文案出策划案与线框图。（笔、Balsamiq Mockup）－设计师出高保真原型（PSD、Sketch、Axure）。－程序（前端后端撰写JavaScript／CSS／HTML代码，后端代码PHP、Node.JS等）其实你提到的网上生成的最终只是把这些步骤通过页面自动帮你实现了，生成的代码页是这些。2.需要用到哪些技术（比如哪些程序语言）前端表现效果：HTML、CSS、JAVASCRIPT后端实现：PHP、Node.JS等。3.微信里的一些特殊的动态效果，比如摇一摇、倾斜手机、举起手机是怎样实现的有些是微信特有的，有些是浏览器本身就支持的。这些其实取决于微信特定的功能开放清单，有些可以做有些不可以做，只要程序根据微信的开放API文档即可实现，文档在这里。微信公众平台开发概述微信提供的JS－SDK工具4.H5页面怎样发布到微信上H5页面其实就是个链接，你可以通过直接将该链接发送给好友、朋友圈、嵌入公众号、嵌入公众号图文也可以通过生成二维码来让用户通过识别二维码来查看链接。草料二维码生成器5.有什么相关参考资料其实对于常见的HTML5工具，取决于你所要制作的形式，对于常见互动展示类，易企秀、MAKA其实足矣，功能非常强大，模版也很丰富。如果你需要的更多互动，甚至游戏类，可以推荐采用24好玩平台。 7.定义函数的方式有哪些，可以写下区别是什么？函数的声明方式：A.基本语法1234function 函数名([参数1],[参数2],...)&#123; 函数体 [return] //返回值&#125; B.字面量定义的形式(匿名函数)1234var 变量=function([参数1],[参数2],...)&#123; 函数体 [return] //返回值&#125; C.以对象的形式来声明12new 关键字var 变量=new function([],[]...,&quot;函数体&quot;); 8.写出正则表达式，用于匹配字符串至少包含五个连续的中文字，例如 中国人ss中国(注：UTF-8格式中文正则字符编码范围：\u4e00-\u9fa5)123456var str=&quot;中国人ss中国&quot;;var reg=/\w/g; 或者var reg=/[a-z]/g; 或者var reg=/[^\u4e00-\u9fa5]/g;var arr=str.replace(reg,&quot;&quot;);console.log(arr);输出结果：‘中国人中国’ 9.jquery中的hover事件等效于哪两个事件的组成?移入移出事件 onmouseover、onmouseout1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;//鼠标移入移出效果&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;$(&apos;.container&apos;).hover(function()&#123; $(this).children().fadeOut(1000); $(this).children().fadeIn(500);&#125;)&lt;/script&gt; 10.JS中哪些情况下会产生undefined值？有许多的方法产生一个undefined值的代码。它通常为当试图访问一个不存在的值时。1.任何变量声明时没有提供一个初始值，就会返回undefined12var foo;console.log(foo); //默认值为undefined 2.当试图访问一个不存在的对象属性或数组项时，返回undefined1234var array = [1, 2, 3];var foo = array.foo; // foo 属性不存在, 返回 undefinedvar item = array[5]; // 数组中没有索引为5的项，返回 undefinedconsole.log(foo,item); 3.如果省略了函数的返回语句，就会返回undefined1var value = (function()&#123;&#125;)(); // 返回 undefined 4.函数调用时提供的参数值为undefined123(function(undefined)&#123; // 参数是 undefined&#125;)(); 11.获取一个数组中的最大最小值，var numbers=[5,145,11,38,400,78,-834];123456789101112var numbers=[5,145,11,38,400,78,834];var max=numbers[0];for(var i=0;i&lt;numbers.length-1;i++)&#123; if(max&lt;numbers[i+1])&#123; max=numbers[i+1]; &#125;else&#123; max=max; &#125;&#125;console.log(max);输出结果&apos;400&apos; 12.数组有哪些自带的方法或属性var arr=[0,1,2];1.pop();删除数组的最后一个元素，减少删除的长度，返回删除的值。这里是22.push(3);将参数加载到数组的最后，返回新数组的长度。这里是43.shift();删除数组的第一个元素，返回删除的值，同时数组长度减一。这里是04.unshift(3,4);把参数加载数组的前面，返回新数组的长度这里是55.sort();按指定的参数对数组进行排序，返回的值是经过排序之后的数组1234567var arr=[0,1,2,5,4];function compare(val1,val2)&#123; return val2-val1;&#125;console.log(arr.sort(compare));这里是[5, 4, 2, 1, 0] 6.reverse();反转数组项的顺序，返回的值是经过排序之后的数组这里是[2,1,0]7.contact(3,4);把两个数组拼接起来，返回的值是一个副本12345var arr=[0,1,2,5,4];var arr2=[7,8,9];console.log(arr.concat(arr2));这里是[0, 1, 2, 5, 4, 7, 8, 9] 8.slice(start,end);返回从元素组中指定开始下标到结束下标之间的项组成的新数组123456789var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];// 一个参数:var color1 = colors.slice(1);alert(color1); // green,blue,yellow,purple// 两个参数：var color2 = colors.slice(1,4);alert(color2); // green,blue,yellow 9.splice()删除：2个参数，起始位置，删除的项数插入：3个参数，起始位置，删除的项数，插入的项替换：任意参数，起始位置，删除的项数，插入的任意数量的项123456789101112var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red,返回数组中只包含一项removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置1开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的数组是一个空数组removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 从位置I开始插入两项alert(colors); // green,red,yellow,orange,bluealert(removed); // yellow,返回的数组中只包含一项 10.indexOf()和lastIndexOf();接受两个参数，要查找的项(可选)和查找起点位置的索引indexOf();从数组开头向后查找lastIndexOf();从数组末尾开始向前查找11.every();对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。12.filter();对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。13.forEach();对数组的每一项运行给定函数，这个方法没有返回值。14.map();对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。15.some();对数组的每一项运行给定参数，如果该函数对任一项返回true，则返回true。以上方法都不会修改数组中的包含的值。16.reduce()和reduceRight();缩小数组的方法，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。17.join(separator);将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符12var a = [1,2,3,4,5];var b = a.join(&quot;|&quot;); //a：[1,2,3,4,5] b：&quot;1|2|3|4|5&quot; 13.你想用前端知识做些什么事，如果给你自由的空间14.如果让你参与一个前端相关的新技术领域研究，你觉得如何能快速掌握]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中Date和new Date的区别]]></title>
    <url>%2F2017%2F07%2F21%2FJs%E4%B8%ADDate%E5%92%8Cnew-Date%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.Date()直接返回当前时间字符串，不管参数是number还是任何string1234Date();Date(&apos;sssss&apos;);Date(1000);//Fri Aug 21 2015 15:46:21 GMT+0800 (中国标准时间) 2.而new Date()则是会根据参数来返回对应的值，无参数的时候，返回当前时间的字符串形式；有参数的时候返回参数所对应时间的字符串。new Date()对参数不管是格式还是内容都要求,且只返回字符串12345678910111213141516171819new Date();//Fri Aug 21 2015 15:51:55 GMT+0800 (中国标准时间)new Date(1293879600000);new Date(&apos;2011-01-01T11:00:00&apos;)new Date(&apos;2011/01/01 11:00:00&apos;)new Date(2011,0,1,11,0,0)new Date(&apos;jan 01 2011,11 11:00:00&apos;)new Date(&apos;Sat Jan 01 2011 11:00:00&apos;)//Sat Jan 01 2011 11:00:00 GMT+0800 (中国标准时间)new Date(&apos;sss&apos;);new Date(&apos;2011/01/01T11:00:00&apos;);new Date(&apos;2011-01-01-11:00:00&apos;)new Date(&apos;1293879600000&apos;);//Invalid Datenew Date(&apos;2011-01-01T11:00:00&apos;)-new Date(&apos;1992/02/11 12:00:12&apos;)//596069988000 new Date()对参数有严格的要求，格式不准确的时候会返回Invalid Date]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie LocalStorage与SessionStorage的区别]]></title>
    <url>%2F2017%2F07%2F20%2FCookie-LocalStorage%E4%B8%8ESessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[“Cookie、LocalStorage、SessionStorage的区别？”这个问题成了近期面试中被问到最多的问题，索性把它归归类，让自己的记忆更加深刻一点。 基本概念CookieCookie是小甜饼的意思，顾名思义，它非常小，大小限制在4KB左右，是网景公司前雇员Lou Montulli在1993年3月被发明的。它的主要用途有保存登录信息，诸如在某一个网站的登录页面看到“记住密码”，这通常就是在Cookie中存入辨识用户身份的数据。 LocalStorageLocalStorage是HTMl5标准中新加入的技术，它并不是什么划时代的新东西，早在IE6时代就有相关技术userData，而当时由于考虑到浏览器的兼容性问题，故而没采用。如今，LocalStorage被大多数浏览器支持，故而炙手可热。 特性 Chrome Firefox Internet Explorer Opera Safari LocalStorage 4 3.5 8 10.5 4 sessionStorage 5 2 8 10.5 4 sessionStoragesessionStorage与LocalStorage接口类似，但数据保存的周期不同。sessionStorage将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭之后，sessionStorage中的数据就会被清空。 三者的异同 特性 Cookie LocalStorage sessionStorage 数据的生命周期 一般由服务器生成 ，可设置失效时间。如果是在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器之后就会失效 存放数据大小 4K左右 一般为5MB左右 一般为5MB左右 与服务器端通信 每次都会携带到HTTP头中，如果使用Cookie保存过多数据，会带来性能问题 仅在客户端（浏览器）中保存，不参与和服务器的通信 仅在客户端（浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，原生的Cookie接口不友好 原生接口 原生接口 应用场景Cookie一个常用的场景就是判断用户是否登录。LocalStorage接替了cookie管理购物车的工作，同时也会保存一些诸如HTML5游戏中产生的本地数据。sessionStorage适用于一些用户填写表单信息。 安全性的考虑不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages如何自定义域名]]></title>
    <url>%2F2017%2F07%2F01%2FGithub-Pages%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[将自己的博客代码托管到Github上时，默认域名为 https://gwemz.github.io ，如何给其添加自定义域名？如通过 http://gwem.tk 这样的顶级域名进行访问？ 首先需要ping gwemz.github.io的ip地址（在后边DNS域名解析地址的时候会用到）如图所示： 得到地址之后进入dnspod中进行设置，添加A记录(这儿需要添加两条A记录，一条记录为*，另一条记录为@)，之前就是这一步遗漏，致使无法正确解析出域名: 需要在github项目中建立CNAME文件并填入域名，这儿不需要添加www，然后进行同步 这儿值得注意的是因为使用的是DNSPOD域名解析，故而在DNSPOD中设置域名解析之前需要在Freenom（其它域名申请地址原理类似）中设置选择自定义的DNS服务器，DNS服务器为DNSPOD中默认给的服务器f1g1ns1.dnspod.net.和f1g1ns2.dnspod.net. 最后，输入你的域名，便会发现域名已经成功和你的项目绑定了！！！]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3属性]]></title>
    <url>%2F2017%2F06%2F27%2FCSS3%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3、CSS4以及其他传说CSS 1 的规范由 Håkon Wium Lie 和 Bert Bos 发表于 1996 年，它非常短，而且比较简单。它的内容少到用一个 HTML 页面就足以呈现了，即使用 A4 纸打印出来也只需要 68 页。 CSS 2 发表于 1998 年，它的定义更加严格，囊括了更多的功能，而且增加了两名编辑：Chris Lilley 和 Ian Jacobs。此时，规范的篇幅暴增到了480 页打印纸，人们已经无法把它完整地记忆下来了。 尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过。这一点跟 CSS 2.1 或更早的 CSS 1 不一样。真正的情况是，绝大多Web 标准 ：是敌还是友 5数编辑在提到这个词时，指的是一个非正式的集合，它包括 CSS 规范第三版（Level 3）再加上一些版本号还是 1 的新规范。尽管在哪些规范应该归入CSS3 的问题上，编辑们达成了一定的共识，但我们也不得不面对现实：由于 CSS 的各个模块在近些年里以不同的速度在推进，我们已经越来越难以把这些规范以 CSS3、CSS4 这样的方式来划分了，而且这样也难以被大众理解和接受。 展示一个大牛的作品，在日常写业务逻辑代码时可作为参考： 豪情前端作品]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禅心慧语]]></title>
    <url>%2F2017%2F06%2F16%2F%E7%A6%85%E5%BF%83%E6%85%A7%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[语录摘录于2017-3-31杭州永福禅寺 无所得，即是得。以是得，无所得。 ————《大般若经》 心情是一条河，它的状态取决于它的深度。深水沉静，浅水喧哗。心量太小，小石头也能激起心情的浪花；心量大了，才能容得下暗藏的礁石。生活中，干扰我们心情的，没多少是大事。如同江河中的浪花，很多都不是庞然大物激起的。见多识广了，心胸就开阔了，心量就大了，心也就容易宁静了。 人生在世，往往会因这样或那样的伤害而心痛不已。罗素说，累累伤痕是生命给你的最好礼物。笑而不语是一种豁达。朋友间的戏谑，遭人误解后的无奈，过多的言辞申辩反而让人觉得华而不实，倒不如留下一抹微笑，任他人做评，有时一个微笑可以让两个宿怨之人冰释前嫌。 在这个世界上，没有一劳永逸，完美无缺的选择。你不可能同时拥有春花和秋月，不可能同时拥有硕果和繁花。你不可能所有的好处都是你的。你要学会权衡利弊，学会放弃一些什么，然后才能得到一些什么。你要学会接受命的残缺和悲哀，然后，心平气和。因为，这就是人生。 走在路上，挫折是难免的，低潮时必然的，孤独与寂寞是如影随形的；总有被人误解的时候，总有寄人篱下的时候，总有遭人诽谤和暗算的时候。这些时候，要知道潮涨潮落、波谷波峰的道理，只要你能够耐心等待，受得了折磨，守得住底线，一切都会证明，生活不会抛弃你，命运不会舍弃你。 凡事不可能一帆风顺。“随缘自适”。随缘是一种进取，是智者的行为，愚者的借口。随不是跟随，是顺其自然，不怨恨、不躁进、不过度、不强求；随不是随便，是把握机缘，不悲观、不刻板、不慌乱，不忘形；随是一种达观，是一种洒脱，是一份人生的成熟，一份人情的练达。 认识一个人靠缘分；了解一个人靠耐心；征服一个人靠智慧；处好一个人靠包容。人，相互帮扶才感到温暖；事，共同努力才感到简单；路，有伴同行才感到平坦；友，相互牵挂才感到情深；坚持与人为善，不遗余力的成就他人，也将在不知不觉中成就自己。一人亦人，众人为天；谋事在人，成事在天。 狮子不怕孤独，所以强大；羚羊喜欢群居，因为弱小。人生无处不修行，能在孤独中心静如水，才能在纷扰里安然无恙。人生来就是孤独的，不要奢望能够依靠谁，哪怕是自亲自爱。越是喧嚣处，往往更孤独。心系一处，自走自路。孤独是人生必走的路、必吃的苦。苦到尽头，甘自来。 每个人的身上，都依附着两个自己：好的自己和坏的自己。让积极打败消极，让高尚打败鄙陋，让真诚打败虚伪，让宽容打败计较，让快乐打败忧郁，让勤奋打败懒惰，让坚强打败脆弱。只要你愿意，你就能做最好的自己。 同是一块石头，一半做成了佛像，一半做成了台阶。一天，台阶不服气的问佛像：“我们本是一块石头，凭什么人们都踩着我，而去朝拜你呢？”佛说：“因为你只挨了一刀，而我经历了千刀万割。”人生亦如此，经得起打磨，耐得起寂寞。 人生有两种境界：一是痛而不言，二是笑而不语。痛而不言是一种智慧，人生在世，往往会因为这样或那样的伤害而心痛不已。对坚强的人来说，累累伤痕是生命赐予的最好的礼物；笑而不语是一种豁达，朋友间的戏虐，遭人误解后的无奈，过多的言辞申辩反让人觉得华而不实，莫不如留下一抹微笑，任他人做评。 人生有四苦：一是看不透。看不透人际中的纠、争斗后的隐伤，喧嚣中的平淡、繁华后的宁静。二是舍不得。舍不得曾今的精彩、不逮的岁月，居高时的虚荣、得意处的掌声。三是输不起。输不起一时的情感之失，输不起一截人生失败。四是放不下。放不下已经走远的人和事，放不下早已尘封的是与非。 人与人的差距，表面上看是财富的差距，实际上是福报的差距；表面上看是人脉的差距，实际上是人品的差距；表面上看是气质的差距，实际上是涵养的差距；表面上看是容貌的差距，实际上是心地的差距；表面上看是人与人都差不多，内心境界却大不相同。 一草一木皆有佛性，都有它生存的空间，当互相尊重。 种树培其根，种德培其心。 世间一切，为我所用，非我所有。 风来疏竹，风去竹不留神；雁过寒潭，雁去潭不留影。 一切有为法，如梦幻泡影。如露亦如电，应作如是观。 -《金刚经》 秋至满山多秀色，春来无处不花香。 无所从来，亦无所去，故名如来。 -《金刚经》 自处超然，处人蔼然。无事澄然，有事斩然。得意淡然，失意泰然。 无所得，即是得。以是得，无所得。 -《大般若经》 禅坐即是相续不断的正念。 天上天下无如佛，十方世界亦无比。世间所有我尽见，一切无有如佛者。 境来不拒，境去不留，一切随缘，能得自在，放下即得解况。 淡泊平怀，便是人生真味。 若有诸众生，为发菩提心。一得闻佛名，决定成菩提。 一念放下，万般自在。 事能知足心常惬，人到无求品自高。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS研究]]></title>
    <url>%2F2017%2F06%2F15%2FVueJS%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[前言前端框架层出不穷，其实不单单是前端，其它方向也是如此，比如最近大热的人工智能(Python语言)，估计接下来有很多人回去学习Python，我们总是这样，看到什么热门，什么最赚钱，然后就一蜂窝投入到那个行业，转悠一圈下来，发现并不适合自己，于是乎又重新开始选择新的职业。。。 接触面广挺好，但是切记贪多，就如猴子搬玉米一般，捡了西瓜丢掉芝麻。那么对于前端而言，最近几年技术层出不穷，框架Angular、React、Vue、Dojo、Ember以及Aurelia等等，javascript近年也是每一年都有新的规范制定，那么这些前端的东西你是否都了解？Python、PHP确实好，但那又如何？ 投身一个行业，那么就去专研就好了，不扯淡了。书归正传，Vue据说是最易学的前端框架，但真正学了之后才发现，并非如此，组件、指令以及路由等等，这一些思想都并非那么容易理解，所以，任重道远，还需要努力学习研究。。。 介绍Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。Vue的核心库只关注视图层，他不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和Vue生态系统支持的库结合使用时，Vue也完全能够为复杂的单页应用程序提供驱动。 官方网站 什么是Vue.js 它是一个轻量级的MVVM框架 数据驱动+组件化的前端开发 GitHub超过25K+的Star数，社区完善引入方式 &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 声明式渲染12345678910&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;) Hello Vue! 绑定Dom元素属性：123456789101112&lt;div id=&quot;app-2&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt;var app2 = new Vue(&#123; el: &apos;#app-2&apos;, data: &#123; message: &apos;页面加载于 &apos; + new Date() &#125;&#125;) 鼠标悬停几秒钟查看此处动态绑定的信息！ 条件与循环条件12345678910&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: &apos;#app-3&apos;, data: &#123; seen: true &#125;&#125;) 现在你看到我了 循环123456789101112131415161718&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;var app4 = new Vue(&#123; el: &apos;#app-4&apos;, data: &#123; todos: [ &#123; text: &apos;学习 JavaScript&apos; &#125;, &#123; text: &apos;学习 Vue&apos; &#125;, &#123; text: &apos;整个牛项目&apos; &#125; ] &#125;&#125;) 1.学习JavaScript2.学习Vue3.整个牛项目 处理用户输入12345678910111213141516&lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;&lt;/div&gt;var app5 = new Vue(&#123; el: &apos;#app-5&apos;, data: &#123; message: &apos;Hello Vue.js!&apos; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) Vue基本的路由结构Vue-cli是Vue的脚手架工具Vue-cli项目地址 项目创建： 全局安装：cnpm install --global vue-cli创建一个基于webpack的新项目：vue init webpack my-project安装依赖：cd my-project npm install npm run dev Webpack官方地址]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native研究]]></title>
    <url>%2F2017%2F06%2F05%2FReactNative%2F</url>
    <content type="text"><![CDATA[如何搭建开发环境？参考文献]]></content>
      <tags>
        <tag>react native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github中ssh密钥的生成]]></title>
    <url>%2F2017%2F06%2F02%2Fgithub%E4%B8%ADssh%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[github中ssh密钥的生成（如何不用输密码同github交互）使用git Bash by winter on 2017/5/21 1. 查看SSH keys是否存在打开git Brash界面–》输入 ssh 如果出现如下界面，代表SSH keys存在 2. 设置 username 和 email，添加远程地址 3. 生成新的ssh key在命令行中输入ssh-keygen -t rsa -C &quot;3396543978@qq.com&quot; 输入passphrase（本步骤可以跳过）不输入则表示没有密码 将新生成的key添加到ssh-agent中: 如果出现如下界面，则创建成功 4. 将ssh key添加到Github中用自己喜欢的文本编辑器打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到GitHub的Add SSH key页面即可 参考文章： Git 最著名报错 “ERROR: Permission to XXX.git denied to user”终极解决方案 多个GITHUB帐号的SSH KEY切换参考文章 winter@DESKTOP-43SLAF5 MINGW64 ~/Desktop$ ssh-add ~/.ssh/id_rsaIdentity added: /c/Users/winter/.ssh/id_rsa (/c/Users/winter/.ssh/id_rsa) How to 切换不同的github账户？ 相关参考文献 文章一 文章二 文章三 文章四 文章五 修改仓库.git目录下config中的配置文件]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A-star算法的研究与应用]]></title>
    <url>%2F2017%2F06%2F02%2Fastar%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[A-star算法的研究与应用搜索区域(The Search Area)我们假设某人想从A点到达B点，一堵墙把它们分开了。如下图所示，绿色是开始点A，红色是结束点B，而蓝色填充的方块是中间的墙。 你应该注意的第一件事是，我们把搜索区域分割成了方块的格子。简化搜索区域，如你目前完成的那样，这是寻路的第一步。这个特殊方法把搜索区域简化成了一个二维数组。数组的每一个项目代表了格子里的一个方块，它的状态记录成可行走和不可行走。通过计算出从A到达B应该走哪些方块，就找到了路径。一旦路径找到，我们的人从一个方块的中心移动到下一个方块的中心，直到抵达目标。 这些中心点称作“节点”。当你在其它地方阅读关于寻路时，你将经常发现人们讨论节点。为什么不直接把它们认为是方块呢？因为有可能你要把你的寻路区域以非方块的东西来分割。它们可能是矩形，六角形，或任何形状，真的。而节点可以放到形状内的任何位置。在中心，或者沿着边缘，或其它地方。然而我们使用这个系统，因为它最简单。 开始搜索Starting the Search一旦我们把搜索区域简化成了可以管理的大量节点，就象我们上面所做的那样采用格子的布局，下一步就是引导一个搜索来找出最短路径。在A*寻路的做法，我们从开始点A做起，检查它周围的方块，并且向外普通的搜索，直到找到目标。 我们这样开始搜索： 从开始点A起，添加它到待考虑的方块的“开放列表”。开放列表有点象购物列表。此时只有一个项目在里面，但很快我们会得到更多。它包含了你可能取用的沿途的方块，也可能不用它。基本上，这是需要检查的方块的列表。 观察开始点邻近的所有可到达或可行走的方块，忽略有墙，水或其他非法地形的方块。也把它们添加到开放列表。对每一个方块，保存A 点作为它们的“父亲”。这个父亲方块在跟踪路径时非常重要。后面会更多的解释。 把开始方块A从开放列表中取出，并放到“封闭列表”内，它是所有现在不需要再关注的方块的列表。 在此，你应该有了类似下图的东西。在这个图中，中间的深绿色的方块就是开始方块。它有浅蓝色的外框，表示它被添加到封闭列表了。所有的相邻方块现在都进入要检查的方块的开放列表中了，它们有浅绿的外框。每一个都有灰色的指针指回它的父亲，它就是开始方块。 下一步，我们从开放列表中，选出一个相邻的方块，然后多多少少重复早先的过程。但是我们选择哪一个呢？具有最小F值的那个。 路径排序Path Scoring找到形成路径的方块的关键是下面的等式： F = G + H 这里 G = 从开始 点A到格子中给定方块的移动代价，沿着到达该方块而生成的那个路径。 H = 从格子中给定 的方块到最终目标 B点的评估移动代价。这种方式通常称作试探法，有点让人混乱。因为这是一个猜测，所以得到这个称谓。在找到路径之前，我们真的不知道实际的距离，因为途中有各种东西（墙，水，等等）。在本教程里给出了一种计算H的方法，但在网上你能找到很多其他的文章。 我们需要的路径是这样生成的：反复的遍历开放列表，选择具有最小F值的方块。 如上所述，G是经由到达它的路径，从开始点到给定方块的移动代价。我们为每个水平/垂直的移动指定代价为10，而斜角的移动代价为14.我们使用这些值，是因为斜角的距离是2的平方根，或者大概是1.414倍的水平/垂直的移动代价。出于简化的目的使用了10和14。比例大致是正确的，而我们却避免了方根和小数的计算。倒不是我们没有能力或者不喜欢数学，使用这些数字也能让计算更快一些。以后你就会发现，如果不使用这些技巧，寻路的计算非常慢。 既然我们沿着给定方块的路径来计算G的值，找出那个方块G值的方法就是找到其父亲的G值，再加上10或者14而得，这依赖于它处于其处于父亲的斜角或者直角(非斜角)而定。这在本例后面会更加清晰，随着我们从开始点离开而得到更多的方块。 H能通过多种方法估算。我们这里用到的方法叫做Manhattan方法，计算从当前方块经过水平/垂直移动而到达目标方块的方块总数。然后将总数乘以10。这种方法之所以叫做Manhattan方法，因为它很像计算从一个地点到达另一个地点的城市街区数量计算，此时你不能斜向的穿越街区。重要的是，当计算H的时候，要忽略任何路径中的障碍。这是一个对剩余距离的估算值，而不是实际值，这就是试探法的称谓由来。 G和H相加就算出了H。第一步搜索的结果见下图的描述。F，G和H值都写入了每个方块。如开始方块相邻右边的方块，F显示在左上方，G显示在左下方，而H显示在右下方。 好，让我们来观察某些方块。在有字母的方块中，G=10。这是由于在水平方向上从开始点(到那里)只有一个方块的距离。开始点相邻上方、下方和左边的方块都具有同样的G值：10。斜角的方块G值为14。 H的计算通过估算Manhattan距离而得，即：水平/垂直移动，忽略途中的障碍，到达红色的目标方块的距离。用这种方法，开始点相邻右边的方块和红色方块相聚3个方块，那么H值就是30。其上的方块距离为4（记住，只能水平/垂直移动），H就是40。你也可以看看其它方块的H值是如何计算出的。 每个方块的F值，再说一下，不过就是G和H相加。 持续的搜索为了继续搜索，我们简单的选择开放列表里具有最小F值的方块，然后对选定的方块做如下操作： 将它从开放列表中选出，并加入封闭列表。 测试所有的相邻方块，忽略封闭列表内的和不可行走的（墙，水及其它非法地形）方块，如果方块不在开放列表中，则添加进去。将选定方块作为这些新加入方块的父亲。 如果一个相邻方块已经存在于开放列表，检查到达那个方块的路径是否更优。换句话说，检查经由当前方块到达那里是否具有更小的G值。如果没有，不做任何事。相反，如果新路径的G值更小，把这个相邻方块的父亲改为当前选定的方块。最后，重新计算那个方块的F和G值。 好了，让我们看看它是怎样工作的。在初始的9个方块中，当开始方块被纳入封闭列表中，我们的开放列表就只有8个方块了。在这些方块中，具有最小F值的是开始方块相邻右边的那个，其F值为40。所以我们选定这个块作为下一个方块。在随后的图示中，它以高亮的蓝色表示。 首先，我们把它从开放列表中取出，并加入到封闭列表（这就是它现在是高亮的蓝色的原因）。然后我们检查相邻的方块。然而，这个方块相邻的右边是代表墙的方块，所以忽略他们。其相邻的左边是开始方块。它处于封闭列表内，所以也忽略它。 其它四个已经在开放列表中了，所以我们需要检查经由当前方块到达他们是否是更优的路径，使用G值作为参考点。我们来看看这个选定方块上面右边的那个方块。它的当前G值是14.如果我们经由当前方块到达那里，G值将是20（10，到达当前方块的G值，再加上10垂直移动到它上面的方块）。20&gt;14，所以这不是一个好的路径。看看图解能够好的理解这些。从开始方块斜向移动到那个方块更直接，而不是水平移动一个方块，再垂直移动一个方块。 当我们队已经存在于开放列表中的4个相邻方块都重复这个过程。我们发现经由当前方块没有更佳的路径，所以什么也不用改变。现在看看所有的相邻方块，我们已经处理完毕，并准备移动到下一个方块。 现在，我们再遍历开放列表，它只有7个方块了，选择具有最小F值的那个。有趣的是，此时有两个方块都有值54。那么我们选择哪个？实际上这不算什么。为了速度的目的，选择你最后加入到开放列表的那个方块更快。当你接近目标的时候，当你更接近于目标的时候，它倾向于后发现的那个方块。但这真的没有什么关系。（不同的处理造成了两个版本的A*可能找到不同的等长路径） 我们选择下面的那个，位于开始方块的右边，如下图所示。 这一次，当检查相邻的方块时，我们相邻右边的是一个墙方块，所以忽略它。对那个方块上面的块同样忽略。我们也忽略墙下面的方块。为什么？因为你不把临近墙的角切开就无法直接到达那个方块。实际上你需要先向下走去，然后越过那个方块。在这个过程中都是围绕角在移动（说明：切开角的规则是可选的。它的使用依赖于你的节点如何设置） 这样就剩下5个方块了，当前方块下的两个方块不在开放列表中，所以，要添加他们，并把当前方块作为他们的父亲。在另外三个方块中，有两个已经在封闭列表中了（开始方块和当前方块上面的那个，他们都用高亮的蓝色在图中标出来了），所以忽略他们。最后一个方块，当前方块相邻左边的那个，检查经由当前方块到达那里是否得到更小的G值。没有。所以处理完毕，并准备检查开放列表的下一个方块。 我们重复这个过程，直到把目标点添加到开放列表，此时的情形如下图所示： 注意开始方向向下的第二个方块，在前面的描述中其父亲已经发生改变，开始它的G值为28，指向其右上角的方块。到现在它的值是20，指向其上方的方块。这是在搜索方法中某处发生的吗？在那里G值被检查，而且使用了新的路径后，它得到了更小的值。所以它的父亲切换了，G和F也重新计算。而这个改变在本例中不见得非常重要，在决定最佳路径的时候，持续的检查会产生各种差别。 那么我们怎样决定实际的路径呢？简单，从红色的目标方块开始，向后移动到它的父亲，跟从箭头的指示，最终你会回到开始方块，这既是路径！它如下图所示。从方块A移动到方块B就是从每一个方块（节点）的中心移动到路径上的下一个方块的中心的简单过程，直到到达目标！ A-star方法汇总好了，现在你已经读完了所有解释，让我们在这里一步一步的列出所有操作： 添加开始方块到开放列表。 重复下面的过程 查找开放列表中具有最下F值的方块。我们把它作为当前方块 把它放入封闭列表 对当前方块的8个相邻方块的每一个？ 如果它不可行走，或者存在于封闭列表中，忽略它。否则执行下面操作。 如果它不在开放列表中，将它添加进去，以当前方块作为其父亲，记录这个方块的F，G和H值 如果它已经在开放列表中了，检查到达那个方块的路径是否更优，以G值为测量值。更低的G值意味着更好的路径。如果找到，这个方块的父亲改为当前方块，并重新计算这个方块的G和F值。如果你保持开放列表按F值排序的话，可能需要重新排序来解决这个变化。 结束循环 当你 将目标方块加入到开放列表，此时路径已经找到，或者 没有找到目标方块，并且开放列表是空的。此时，没有路径。 保存路径，从目标方块往回走，从每个方块走到它的父亲方块，指导抵达开始方块，那就是路径。 当你在网上和分类论坛阅读很多讨论A-Star寻路的时候，你有时候会发现某些人所指的A代码实际上并不是真正的A算法。对于应用中的A算法，你需要包含上面讨论到的元素 –特别是开放列表和封闭列表，以及使用了F、G和H的路径排序。有很多其它的寻路算法，但是其它的方法并不是A 通常认为它是最好的方法。 关于实现的提示现在你已经理解了基本的方法，这里是当你需要些自己的程序时需要考虑的更多的东西。下面的某些材料引用了我用C++和Blitz Basic写的程序，但是这些要点对其它语言也是同样有效的。 维护开放列表：实际上这是A*寻路函数最好费时间的函数之一。每次访问开放列表时，你都需要找到具有最小F值的方块。有很多种方法可以做到这一点。你可以保存所需的路径项目，每次当你需要找到最小F值的方块时，简单的遍历整个列表。这很简单，不过路径长的时候非常慢。这个方法可以改进，通过维护一个排序的列表，每次需要最小F值的方块时，简单的抓出第一个项目就可以了，当我写自己的程序时，这是我用到的第一个方法。 其它单元：如果你碰巧的阅读我的范例代码，将会注意到它完全忽略了地图上的其它单元。我的寻路怪物实际上是穿越彼此而通过。依赖于游戏，这可能是正确的，或者是不正确的。如果你需要考虑地图上的其它单元，并让他们能围绕彼此移动，我建议你在寻路代码里忽略其它单元，而另外写一些代码来检测两个单元是否发生了碰撞。当碰撞发生时，你可以生成一个新的路径或者使用一些标准的移动规则，指导障碍不在路上，然后生成新路径。当计算初始路径时，为什么不包含其它单元？嗯，因为其它单元会动，他们可能不在自己的位置，当你到达那里的时候。这会造成一些怪异的结果，路径计算后，在某处单元突然转向避开一个不再停留在那里的单元，却撞上了另一个经过它路径的单元。 寻路代码中忽略其他的单元，然而，这意味着你要写单独的代码来处理碰撞。这是和游戏很相关的，所以我把决定权留给你。本文后面的参考资料一节里， Bryan Stout的文章值得一读，里面有一些可能的解决方案（如强力跟踪[robust tracing]，等等）。 关于速度的更多技巧 ：当你开发自己的A*程序，或者改编我所写的那个，最终你会发现寻路使用了大块的 CPU时间，特别是当你有大量的寻路怪物，运行在一个相当大的地图上的时候。如果你读网上的资料，你会发现甚至象星际争霸[Starcraft]或者帝国时代[Age of Empires]这样的专业游戏也会遇到这些问题。如果你发现由于寻路导致运行变慢，这里有一些可能提高速度的主意： 考虑小一些的地图或者少一些的怪物。 不要一次对太多的怪物做寻路。而是把他们放入队列，从而把他们分散到更多的游戏循环。如果你的游戏运行在，比如，40帧/秒，没有人会注意到。但是他们会注意到每一小段时间的游戏变慢，当大量的怪物都在同一时间寻路的时候。 考虑对地图使用大一些的方块。这样就减少了寻路要搜索的方块总数。如果你有雄心的话，可以设计两种或更多寻路系统，依赖于路径的长度而用于不同的场合。这就是专业人士的做法，对长路径使用大的区域，然后当接近目标时切换到使用小一些的方块/区域的精确搜索。如果你对这个概念有兴趣，参考我的文章Two-Tiered A* Pathfinding。 考虑对较长的路径应用路点系统，或者设计预计算[precalculated]的多个路径，它们对游戏是固定不变 [hardwired]的。 考虑预处理地图，计算出哪些区域是从其他区域不可到达的。我把这些区域叫做“岛屿”。实际上，他们也可以是岛屿或者其他围了墙而无法到达的区域。A*的缺点之一就是，如果你告诉它搜索到达这些区域的路径，它会搜索整个地图，仅当每一个开放列表和封闭列表中的可到达方块/节点都处理后，才会停止。那会浪费大量的CPU时间。这种现象是可以避免的，通过预先决定那些区域是无法到达的，用数组或者类似的数据结构记录这些信息，然后在开始路径搜索前检查它。在我的代码的Blitz版本中，我创建了一个地图预处理器[map pre-processor]来做这件事。它也预先检查寻路算法可以忽略的死点[dead-ends]，这样速度就提高了很多。 多样的地形代价： 在本教程以及我的附带程序里，地形只有两种情况：可行走和不可行走。如果你有可以行走但移动代价更高的地形怎么办？沼泽，山坡，地下城的楼梯，等等？这些都是可行走而移动代价高于平坦地面的地形实例。同样的，道路可能具有比它周围地形小一些的移动代价。 这个问题很容易解决，当计算任意给定的方块的G值时，加上地形的代价。简单的加上一个奖励代价给这些方块。A寻路算法已经写成查找最小代价的路径，应该容易处理它。在我描述得简单示例中，当地形只有可行走和不可行走时，A能找到最短，最直接得路径。但是在多代价[variable-cost]地形环境中，最小代的得路径可能行走了较长的距离。如同选择围绕沼泽的道路，而不是直接穿越沼泽。 还有一个有趣的附加考虑是被专业人士称作“影响映射[influence mapping]”的东西。如同上面描述的多代价地形一样，你可以创建一个附加的点系统，并引用到AI的路径中。想象你有一个地图，有大量的怪物守护着穿越山区的通道。每次当电脑送某人到经过这个通道的路径时，都会被困住。如果你愿意，你可以创建一个影响地图，处罚发生大量流血残杀处的那些方块。这会教电脑偏好安全的路径，并帮助它避免不利的位置：仅仅由于路径更短（但更危险），而不停的输送部队和怪物通过这个路径。 处理未探索区域： 你是否玩过一款PC游戏，在那里电脑总是准确的知道路该如何走，即使地图没有探索？依赖与游戏，那样的寻路太好了反而不够真实。幸运的是，这个问题很容易解决。 答案就是创建一个独立的“发现可行走[knowWalkability]”数组用于每一个玩家以及电脑对手（每一个玩家，不是每一个单元 – 那将需要更多的计算机内存）。每个数组包含了玩家已探索区域的信息，另一方面，地图上其它区域直到被证实后才被假设是可行走的。使用这个方法，单元会漫步于死点位置，重复做相同的错误选择，直到他们发现周围的路。一旦地图都探索了，寻路就正常工作。 更平滑的路径： 虽然A*会自动给出最短的，最低代价的路径，它不会自动给出看起来最平滑的路径。看一看本例最后计算出来的路径（图 7）。那条路径的第一步位于开始方块的右下方。如果第一步的方块就是开始方块相邻下方的方块，路径会不会更平滑些？ 有很多方法可以解决这个问题。当你计算路径的时候，要处罚那些改变方向的方块，给它们一个附加的G值扣分。这样计算后，你可以走一遍那条路径，看一看那些选择了邻近方块而让路径看起来更好的地方。关于这个问题的完整信息，参考Gamasutra.com上Macro Pinter的文章 Toward More Realistic Pathfinding，它是免费的，但需要注册。 非方块搜索区域： 在我们的示例中，我们使用了一个简单的2D方块布局。你不必使用这个方法。你可以使用不规则的形状区域。考虑一下棋盘游戏Risk，和游戏中的国家。你可以设计一个象那样的寻路关卡。为此，你将需要创建一个表来存储哪些国家和哪些国家相邻，以及相关的从一个国家移动到另一个国家的G值。你也需要选择一种估算H值的方法。其它的处理就和上面示例一样。当添加新项目到开放列表中时，你将简单的查找表中的国家，而不是邻近的方块。 同样的，你可以创建一个路点系统，对于固定地形场景中的路径。路点通常是一条路径上往来移动的点，这路径可能是一条道路，也可能是一个地下城的关键通道。作为游戏设计者，你能预先指定这些路点。如果没有障碍存在于两个路点间的直线路径上，就可以认为它们是“相邻”的，如同在Risk中那样，你应该保存这些邻接信息到一个某种类型的查找表中，当生成新的开放列表项目的时候使用它。然后记录相关的G值（可能是节点间的直线距离）和H值（可能是节点到目标的直线距离）。其他的和往常一样处理。]]></content>
      <tags>
        <tag>A-star</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo你的博客]]></title>
    <url>%2F2017%2F06%2F02%2Fhexo%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[如何利用Hexo搭建个人博客？ hexo简介hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上. 1231. 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。2. 如果你跟我一样喜欢折腾下，30分钟也足够个性化。3. 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。 搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。 只需要几个简单命令，你就可以完成一切。 123hexo n #写文章hexo g #生成hexo d #部署 # 可与hexo g合并为 hexo d -g 环境准备安装node到Node.js官网下载相应平台的最新版本，一路安装即可。 安装gitHexo之next主题设置首页不显示全文(只显示预览) 写文章执行new命令，生成指定名称的文章至hexo\source_posts\postName.md。 1hexo new [layout] &quot;postName&quot; #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- hexo generate(hexo g) #生成静态文件 hexo server(hexo s) #启动本地服务器查看 参考链接]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无论如何请再坚持下]]></title>
    <url>%2F2017%2F04%2F24%2F%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E8%AF%B7%E5%86%8D%E5%9D%9A%E6%8C%81%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[有人告我说，说在大城市找不到工作，生活很困难，要混不下去了，准备回老家发展、找工作去。 不知道有多少人有这样的想法，起码现在的我就有，但是我想告诉你们的是，无论如何，请务必在大城市再坚持下。 没有去过大城市的人，第一印象对大城市的印象是，房价高的离谱，消费高的吓人，节奏快，压力大，心里不理解那些在大城市为了房子打拼一辈子的房奴到底是哪根筋搭错了。没错，在没来上海之前以上也是我心里对大城市的看法，我还心想，估计这辈子都不太可能会在大城市待下去，人活着怎么都是一辈子，为何不能活的潇洒些呢？ 然而，我来到上海之后，包括这些年自己的亲身经历，让我重新认识了我眼中的大城市。 不得不承认，大城市是残酷的。在这里，你没有亲人，甚至没有朋友，你没有任何人可以依靠，生存全靠自己，脱离了家人亲戚的照顾，你从来不会知道生活有多么困难，现在的时代，无论你家里再怎么贫穷，但是在家里呆着，解决温饱绝对没问题。然而在大城市，不工作是真的是会饿死人的，这里干什么都需要钱，没有钱寸步难行，在大城市，你首先考虑的绝不是生活条件的问题，而是生存的问题，在没来上海之前，我从来没法想象租住的房子竟然会这么小，更没法想象会为了省一块钱的交通费，每天都多走将近一个小时的路程，她，就是这般的不近人情。 然而，大城市是公平的。试想下，在老家办事是怎样的？不管是公事私事永远别想按照正常流程办事，想办成事永远都得陪着笑脸，找关系，送礼。不管你在哪个企业工作，人际关系和家族关系基本就是一切，在这里，努力算什么东西，能力算个屁。而在大城市，没人在乎你的家庭背景，人际关系，这里人人平等，你只要有能力，就能得到更多机会，得到应有的回报，再也不用陪着笑脸，在酒桌上谈生意，也许我们一无所有，但是起码我们还可以努力。在这里，即使输你都输的心服口服，因为那些比你强的人往往比你更努力，比你更有能力。 大城市机会更多，而且有志同道合的朋友一起奋斗。很多人觉得在大城市找不到工作，那就回家试试吧。在大城市数以万计的工作机会你都找不到，回家就能轻易找到工作了？当然也许托家里人找点关系，可能会在家里找到工作，而且很有可能是机关部门，拿着那少的可怜的工资，每天上班就是喝茶、聊天、游戏、吃饭、睡觉、上网，可能还需要没事的时候拍拍马屁，你才 20 多岁，这真的就是你想要的生活么？你想找个志同道合的人聊聊互联网，聊聊科技，在别人眼中你就是异类。然而在大城市，你周围身边有各种各样志同道合的小伙伴，他们有着共同的爱好，共同的梦想，可以一起聊互联网、聊产品、聊技术、聊创业，你在这里可以接触各种各样的机会，接触到第一手的信息与技术，身边充斥着各行各业普通的不能再普通的专业人才，无形中会逼着你去学习，去进步，甚至很有可能一起做出一番事业说不定。 当然，如果我家庭条件不错，家族关系还可以，在老家买辆好车，盖栋楼房，娶个姑娘，过着无忧无虑的生活，这是谁都向往的，没有任何一个人愿意背井离乡，远离父母，孤身一人来到陌生的城市打拼，然而我没有这样的家庭条件，我想可能大部分读者都跟我一样，农村出身，家里能供自己上完大学可能就已经是倾尽全力了，我们想要出人头地，回报父母，回报家人，只有靠自己！ 我当然知道北上广房价高的可能一辈子都买不起，买个包子还要排老长的队，坐地铁挤得像汉堡包，买辆车还要摇号，一个破车牌 8 万多块。 我也知道当你一个人遇到事情孤立无援，叫天天不应，叫地地不灵，又不忍让家里人担心，只能擦干眼泪，忍着痛楚，当做什么都没发生的无奈的坚强。 我更知道那个陪你住 800 块一个月的房子，住房面积不过十平米，什么都给不了她，哪怕一句承诺都给不了的，但是依然对你不离不弃的那个女孩子本可以回家过着更好的生活。 也许你现在的生活过的像条狗，也许你现在只拿着月薪 3000 甚至不够温饱的工资，但是我们还年轻，我们选择在大城市奋斗的原因是因为我们期待的是未来，未来更好的职业发展，未来更好的经济收入，未来更好的生活，以及未来无限的可能。 所以，如果你在大城市感觉快要坚持不下去了，我帮不了你们，也没人能帮得了你们，我能做的就是提醒下你们请务必再坚持下，很多事情，很可能就差那多一点的坚持，仅此而已。 其实大城市与小城市只是一个选择的问题而已，无关对错，只是如果你跟我一样是个农村的孩子，试图凭借自己的本事改变自己的生活，那么我建议你一定要到大城市闯闯，她不问你的出生，背景，更不会鄙视你的家庭条件，她只看你是否努力，真的。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架MVC、MVVM、MVP介绍]]></title>
    <url>%2F2017%2F04%2F24%2FMVC%E4%BB%A5%E5%8F%8AMVVM%20MVP%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. MVCModel-View-Controller(模型-视图-控制器)是最常见的软件架构之一，业界有着广泛应用。 视图（View）：用户界面 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信如下： View传送指令到Controller Controller完成业务之后要求Model改变状态 Model将新的数据发送到View，用户得到反馈 接受用户指令时，MVC的两种方式：（互动模式） 另一种是直接通过Controller接受指令 2. MVPMVP模式将Controller改名为Presenter，同时改变了通信方向 各部分之间的通信，都是双向的 View与Model不发生联系，都是通过Presenter传递 View非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View）,即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里 3. MVVMMVVM模式将Presenter改名为ViewModel，基本上与MVP模式完全一致 唯一的区别是，它采用双向数据绑定（data-binding）:View的变动自动反映在ViewModel，反之亦然。Angular和Ember都采用这种模式]]></content>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPCMS的安装流程]]></title>
    <url>%2F2017%2F04%2F24%2Fphpcms%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234561. 本地服务器www目录下新建文件phpcms2. 在网站www.phpcms.cn下载安装包。有GBK 和 UTF8两个版本，推荐使用UTF8版本。下载文件解压，删除readme文件夹，将install_package文件夹下的文件拷贝到www目录下的phpcms文件夹内3. 访问localhost/phpcms/install/install.php按照指导进行安装 不懂本教程，没关系，查看 详细教程 注：后台管理系统中的设置可修改默认站点域名 三个重要的地址12345localhost/phpcms/admin.php(后台管理系统 账号：phpcms 密码：phpcms)localhost/phpcms/index.php(前台首页文件)localhost/phpcms/myadmin(数据库) 两个重要的目录1231. www/phpcms/phpcms/tmplates/default/content/2. www/phpcms/statics/ -css/ -images/ -js/]]></content>
      <tags>
        <tag>phpcms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wamp下apache2.4.9局域网ip访问时提示403错误]]></title>
    <url>%2F2017%2F04%2F24%2Fwamp%E4%B8%8Bapache2.4.9%E5%B1%80%E5%9F%9F%E7%BD%91ip%E8%AE%BF%E9%97%AE%E6%97%B6%E6%8F%90%E7%A4%BA403%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[在自己的笔记本上搭建了一个apache服务器，想通过手机访问主机上的一个页面，但是在访问过程中总提示403错误。经过在网上查找别人的解决方案，及不断尝试修改httpd.conf配置文件，最终测试出修改方案。 找到(目录C:\wamp\bin\apache\apache2.4.9\conf下的httpd.conf文件)123&lt;Directory&gt;Require local&lt;/Directory&gt; 将 Require local 修改为 Require all granted 真心是尝试过很多修改方法，网友们也说去修改什么allow from all类似这种，都有尝试过。可能是版本不同吧，本方法经测试OK，希望对大家有帮助。]]></content>
      <tags>
        <tag>wamp</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决WampServer 80端口号被占用的问题]]></title>
    <url>%2F2017%2F04%2F24%2Fwampserver%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8%2F</url>
    <content type="text"><![CDATA[沿着C:\wamp\bin\apache\apache2.4.9\conf目录，找到文件httpd.conf文件将80端口号改为任意值，诸如8080端口： 改完之后重启WampServer就会发现软件图标变为了绿色 但是“Localhost”、“phpMyAdmin”、“SQLiteManager”，你可以点击打开看到依旧是默认的80端口。 找到wamp安装目录下的wampmanager.tpl文件，记事本打开： 找到wamp安装目录下的wampmanager.ini文件 将本文件中的http://localhost 替换为 http://localhost:8080]]></content>
      <tags>
        <tag>wampserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有思考的人]]></title>
    <url>%2F2017%2F04%2F24%2F%E6%9C%89%E6%80%9D%E8%80%83%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[这几天看了好多技术大牛的博客，颇有感悟，尤以stormzhang和陈三以及Phodal的博客最深刻，知道这帮闷骚的技术男除了每天都在研究技术之外，也在写一些生活中的感悟、撒撒狗粮等等，技术性文章可以慢慢研读，但是看了很多他们对于不同面的一些感悟。 干货推荐： 博客推荐stormzhang Phodal 陈三 阮一峰 豪情 nate-river Allkcy 技术性文章推荐我的职业是前端工程师 Growth: 全栈增长工程师指南 文艺文章推荐待我代码编成，娶你为妻可好]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2F2017%2F04%2F24%2F%E6%9C%89%E6%84%8F%E6%80%9D%E8%AF%AD%E8%A8%80%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[知乎上有网友提问：我读过很多书，但后来大部分都忘记了，那读书有什么用呢？ 有人说：当我还是个孩子的时候，我吃过很多食物，虽然现在已经记不起来吃过什么了。但可以肯定的是，它们中的一部分已经长成了我的骨头和肉。 其实，何止是读书呢？ 每一次旅行都让我们脚下的路更长更远， 每一次尝试都给我们的世界打开一个新的大门， 每一段感情都让我们的心灵更加感性丰满。 我们的一言一行，所作所为，那些有用的无用的，都在一点点变成我们成长的骨头和肉。 本人学识渊博、经验丰富，代码风骚、效率恐怖，c/c++、java、php无不精通，熟练掌握各种框架，深山苦练20余年，一天只睡4小时，千里之外定位问题，瞬息之间修复上线。身体强壮、健步如飞，可连续编程100小时不休息，讨论技术方案5小时不喝水，上至带项目、出方案，下至盗账号、威胁pm，啥都能干。泡面矿泉水已备好，学校不支持编程已辍学，家人不支持编程已断绝关系，老婆不支持编程已离婚，小孩不支持编程已送孤儿院，备用电源万兆光纤永不断电断网，门口已埋雷无人打扰 网易云扎心评论 我在最没有能力的年纪，碰见了最想照顾一生的人。 我说，我要用一生学这首歌，然后唱给她听，问她愿意陪我吗？她说，她会陪我学。 你那么善解人意，想必没有人爱你。 别人稍一注意你，你就敞开心扉，你觉得这是坦率，其实这是孤独。 多少人以朋友的名义默默的爱着。 高中毕业后做了六年的婚礼司仪了，见证了无数新人的幸福时刻，直到有一天，我“笑着”主持了高中暗恋三年女孩的婚礼。 年龄越来越大，朋友越来越多，兄弟越来越少。 5年前，我大她2岁，现在我大她7岁了。 今天去看了大圣归来。旁边有个小孩问他妈妈，“这个不是动画片么？为什么有这么多大人来看？”他妈妈回答：“因为他们一直在等大圣归来啊，等啊等啊，就长大了。” 嘴上说着单身挺好，可是看到两个人，还是会沉默。 我想做一个能在你葬礼上描述你一生的人。 当你觉得孤独无助时，想一想还有几十亿的细胞为你一个人而活。 校服是我和她唯一穿过的情侣装，毕业照是我和她唯一的合影。 最怕一生碌碌无为，还说平凡难能可贵。 哭着吃过饭的人，是能够走下去的。 多数人25岁就死了，但直到75岁才埋。 手机上存满了分手的歌，好像我谈过恋爱似的。 问她为什么包里总带一把伞，她说因为下雨的时候没有谁来送伞，也没有随陪淋雨。不带伞的话，站也不是，走也不是，像个可怜的笑话。 年少时的爱情，就是欢天喜地地认为会与眼前人过一辈子。所以预想以后的种种，一口咬定它会实现。直到很多年以后，当我们经历了成长的阵痛、爱情的变故，走过千山万水后才会幡然醒悟，那么多年的时光只是上天赐给你的一场美梦，为了支撑你此后坚强地走完这冗长的一生。 你那么擅长安慰他人，一定度过了很多自己安慰自己的日子吧。 “人生好辛苦，还是长大就好了？”“一直如此。” 人一旦矫情起来啊，听什么都像在唱自己。 相关github表情符号见：github表情符号]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到底是我们改变了世界，还是世界改变了我们]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%88%B0%E5%BA%95%E6%98%AF%E6%88%91%E4%BB%AC%E6%94%B9%E5%8F%98%E4%BA%86%E4%B8%96%E7%95%8C%EF%BC%8C%E8%BF%98%E6%98%AF%E4%B8%96%E7%95%8C%E6%94%B9%E5%8F%98%E4%BA%86%E6%88%91%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[图片来自网络 曾梦想仗剑走天涯，无奈梦终究是梦，现实还是太骨感， 走出校门，好多事你都需要考虑，毕竟是一个成年人，有着健全的身体，在学校心里边想着：丫掌握这么多技术，出去随便干什么都可以养活的了自己，更别说身上还扛着这么大的一把剑 但是在每天投着上百份的简历，结果约到的面试还是聊聊无几之后，心里就不由为自己打上了一个大大的疑问号？别人干起来那么轻松的事，丫为什么到你身上这么难，每走一步都是一个坑 久不联系的同学，找到你就给你塞一个高难度任务，在你自己的任务都还没完成的情况下，耗费整天的时间帮他解决问题，解决不好总觉的成了千古罪人 感觉待在哪儿都那么不自在，总觉的自己怎么那么多余，一无是处，浪费资源 但是第二天醒来，该干嘛还是得干嘛，因为毕竟的活着，不为别人，只为能靠自己的力量活着 如果哪一日要是有所小成，我想说绝不是因为别人，而是这个社会把你变的这般厚颜无耻。。。。。。 到底是我们改变了世界，还是世界改变了我们？]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic安装和项目的创建]]></title>
    <url>%2F2017%2F04%2F24%2Fionic%E5%AE%89%E8%A3%85%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[说来惭愧，都说隔行如隔山，没想到自己对同行的了解都微乎其微，还成天称是程序猿，直到前几天自己才听到Ionic,上度娘一问，瞬间就泪崩了，竟然在我身边有PhoneGap、cordova、AngularJS、nodejs、npm等等这么多“赫赫有名”的专有名词我以前竟然听都没听到过，可想自己是有多无知，以下是我这几天科普来的，错误之处还望指出，谢谢！ What is the Ionic？Ionic 是一个强大的 HTML5 应用程序开发框架，号称Advanced Html5 Hybrid Mobile AppFramework 是 AngularJS 移动端解决方案 可以帮助您使用 Web 技术，比如 HTML、 CSS 和JavaScript 构建接近原生体验的移动应用程序。 Ionic 主要关注外观和体验，以及和你的应用程序的 UI 交互，特别适合用于基于 Hybird 模式的 HTML5 移动应用程序开发..…. What is the PhoneGap ?PhoneGap是一个用基于HTML，CSS和JavaScript的，创建移动跨平台移动应用程序的快速开发平台。PhoneGap是一个跨平台的移动app开发框架，可以把html css js写的页面打包成跨平台的可以安装的移动app，并且可以调用原生的几乎所有的功能，比如摄像头，联系人，加速度等。 What is the Cordova ?Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。 Cordova是PhoneGap贡献给Apache后的开源项目，是从PhoneGap中抽离出的核心代码，是驱动PhoneGap的核心引擎。有点类似Webkit和Google Chrome的关系。渊源就是：早在2011年10月，Adobe收购了Nitobi Software和它的PhoneGap产品，然后宣布这个移动Web开发框架将会继续开源，并把它提交到Apache Incubator，以便完全接受ASF的管治。当然，由于Adobe拥有了PhoneGap商标，所以开源组织的这个PhoneGap v2.0版产品就更名为Apache Cordova。 What is the AngularJS ?AngularJS 是一个JavaScript 框架。它是一个以JavaScript 编写的库。AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素”背后”添加代码。AngularJS 支持输入验证。 What is the NodeJs?Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 其实吧，可以认为 Node.js 就是运行在服务端的 JavaScript。 What is the NPM ?NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 新版的nodejs已经集成了npm，所以装了nodejs的话npm也一并安装好了。可以通过输入”npm -v”来测试是否成功安装。 How to make 移动应用(App)有三种方式可以为手机制作移动应用： 原生应用（Native app） 手机网站（Mobile website） 混合应用（Hybrid app） 原生应用（Native app）如上述，你可以根据不同系统平台指定SDK制作对应系统平台下的移动应用，如果你想要为iOS系统创建一款应用，你需要： 拥有一台苹果Mac电脑，当然其他方法也可以，但是我不推荐。作为初学者，一台廉价的Mac Mimi就可以了。 从App store下载Xcode 购买苹果开发者许可证（Apple Developer license）99刀￥一年（如果你想要在App store上发布应用） 你可以利用Swift语言或者它的前辈ObjectiveC语言创建App，Swift 语言在沉重的ObjectiveC语言上做出了巨大改进，如果你决定开发原生app，相比利用ObjectiveC开发原生app，Swift更容易上手，特别是当你有Web开发的背景时。 如果你想要为Android系统创建一款原生应用，你需要： 拥有一台电脑 下载合适的SDKs（后面将会讲到） 购买谷歌开发者许可证（Google Developer license）25刀￥（如果你想要在Google Play Store上发布应用） 利用原生开发技术开发的应用具有速度快和直接利用原生API的优势（你不需要像开发混合应用一样【Hybrid App】作任何中间封装），缺点是，你需要为不同手机系统平台开发不同版本的移动应用。（撰写多套代码） 手机网站（Mobile website）通过手机浏览器可以访问手机网站，手机网站可以根据手机屏幕大小自适应。由于手机网站比较难以维护，一种叫做响应式网站设计（responsive website design）的方法被使用，通过这种方法你拥有一套HTML代码库，你可以通过使用媒体查询（Media queries）根据不同设备不同分辨率（resolutions）改变他们的网站外观。jQuery mobile 是一种出色的移动框架。使用它你可以制作一款移动版本的Web应用程序。移动网站一个显著的优势就是你可以根据需要实时更新他们的内容，而不用去等待苹果Apple或者谷歌Google的审核，劣势则包括低耦合，更少的特征。 混合app（Hybrid app）混合应用基本上是一款手机应用，它和撰写网站的程序语言基本相同，唯一不同的就是他们包含在一个孤立的浏览器中（WebView）， 原生应用通过WebView运行Web应用，混合应用可以调用手机摄像头、GPS等，通过利用插件，混合应用可以调用手机其它的硬件功能，你可以利用开发Web应用的技术开发混合应用。然而，WebView有速度的限制， 制作成熟的3D图像游戏可能不是最好的选择。 安装Ionic1. 需要有JDK和SDK环境，这是Android开发必有的平台（JDK在技术文章003中已经详细阐述了）安卓SDK下载以及环境的配置： 下载地址：（可以使用包含的 sdkmanager 下载其他 SDK 软件包 需要翻墙）立即下载 安卓开发相关资源链接 包含Android Studio 下载后双击安装，指定Android SDK的安装目录，为了方便使用Android SDK包含的开发工具，我们在系统环境变量中的Path设置Android SDK的安装目录下的tools目录。 在Android SDK的安装目录下，双击“SDK Manager.exe”，打开Android SDK Manager，Android SDK Manage负责下载或更新不同版本的SDK包，我们看到默认安装的Android SDK Manager只安装了一个版本的sdk tools。 打开Android SDK Manager，(tools目录下的android.bat)它会获取可安装的sdk版本，但是国内有墙，有时候会出现获取失败的情况。 12345678910111213**配置Android环境变量**- 默认路径安装后，安装完成，开始配置环境变量。- 打开计算机属性——高级系统设置——环境变量- 新建一个环境变量，变量名：ANDROID_HOME，变量值：E:\android_sdk\tools_r25.2.3-windows（以你安装目录为准,确认里面有tools和add-ons等多个文件夹），点击确认。- 在用户变量PATH后面加上变量值%ANDROID_HOME%\platform-tools;点击确认即可。 在系统变量path中添加;E:\android_sdk\tools_r25.2.3-windows\toolsAndroid SDK配置完成，接下来验证配置是否成功。点击运行——输入cmd——回车——输入adb——回车，如果出现一堆英文，即表示配置成功，在输入Android，启动Android SDK Manager。 2. 下载Node.js，安装Node.js下载地址： https://nodejs.org/ 安装都选默认的就行 装好之后，nodejs会默认配好环境变量，你可以去path路径查看 Node Pakcege Manager（NPM）会在安装Node.js时同时安装其它的包，为了检验Node.js是否在Windows上安装成功，在终端上运行下面的命令： node -v 你会获得类似下面的版本信息： v0.12.7 3.安装Git你仅仅需要下载和运行它，根据相应的指引安装即可。为了验证你是否在Windows/Mac上安装Git成功，在终端运行下面的命令行： Git 你会获得如下输出： 4.安装ionic和cordova 打开node.js command prompt使用npm install –g cordova ionic进行安装cordova和ionic（可以分开安装，npm install –g cordova 和 npm install –g -ionic）,很明显，在天朝使用这种方法安装有点行不通。 不用急，咱天朝子民有天朝子民的方法，使用淘宝镜像是网上很多人用的方式输入npm install –g cnpm –registry=https//registry.npm.taobao.org,安装完成之后，以后的插件都可以使用cnpm来替代npm来安装cnpm install –g ionic cordova 如果上面方法还不行，就看这里吧1.npm config –globalset registryhttp://registry.cnpmjs.org 2.npm install –g cordova ionic 查看ionic和cordova是否安装 ionic ionic –v cordova –v 5. 创建项目如果你仅仅只运行ionic start appname 命令，Ionic CLI将会构建一个bootstrap应用（所有需要的构建都会在appname文件夹里面），伴随着空的模板，这儿有其他三个模板包括blank（空模板），sidemenu（侧边栏）和tabs（底部导航栏），除此之外，你可以使用Github repo starters和Codepen URL starters等模块，为了获得更多的starter apps模块，你可以访问 这篇文章 ，在我们的例子中，我们将会使用sidemenu（侧板栏）模板，在终端运行下面的命令： ionic start g_app1 sidemenu 通过cd命令进入你的项目:$ cd g_app1 设置项目使用Sass:ionic setup sass 在本地浏览器中实时开发:ionic serve 添加一个系统平台 (ios or Android):ionic platform add iOS [Android] 注意: iOS 开发需要OS X系统 注意2：在ionic build的时候需要使用VPN 否则它的包下载的非常慢！！！ 详细见Android平台开发指南 编译你的app:ionic build 在模拟器上运行你的app:ionic emulate 在真机上运行你的apps（安装应用到插入电脑的Android手机上）:ionic run 使用ionic打包服务打包一个app:ionic package 12345注意：npm install -g ionic cordova （此处安装很费劲，，，，如果安装不上，请直接使用国内镜像），也可以安装cnpm，这样就容易装cordova和ionicnpm install -g cordova --registry https://registry.npm.taobao.orgnpm install -g ionic --registry https://registry.npm.taobao.org]]></content>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发面试题一]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1. WEB标准以及W3C标准是什么？标签闭合、标签小写、不乱嵌套、使用外链的css和js、结构行为表现的分离 2. xhtml和html有什么区别？XHTML元素必须被正确的嵌套，闭合，区分大小写，文档必须拥有根元素 3. 行内元素有哪些？块级元素有哪些？行内元素 a b img em i span input select 块级元素 div p h1-h6 form ul dl ol table 4. 行内元素和块级元素有什么区别？行内元素不可以设宽高，不独占一行 块级元素可以设置宽高，独占一行 5. 我想让行内元素跟上面的元素距离10px，加margin-top，padding-top可以吗？margin-top和padding-top无效 6. CSS的盒模型由什么组成？内容、padding、border、margin 7. 说说display属性有哪些？可以做什么？display:block 行内元素转换为块元素 display:inline 块级元素转换为行元素 display:inline-block 转换为内联元素 8. CSS的选择符有哪些？ id选择器(#myid) 类选择器(.myclassname) 标签选择器(div,h1,p) 相邻选择器(h1+p) 子选择器(ul&gt;li) 后代选择器(li a) 通配符选择器 属性选择器(a[rel=”exrernal”]) 伪类选择器(a:hover;li:nth-child) 9. 哪些CSS属性可以继承？ 可继承性：font-size font-family color 不可继承性：border padding margin width height 10. CSS优先级算法如何计算？ !important&gt;id&gt;class&gt;标签 11. text-align:center 和 line-height有什么区别？ text-align是水平对齐 line-height是行间 12. 前端页面由哪三层构成，分别是什么？作用是什么？ 结构层（html）、表示层（css）、行为层（js） 13. 标签上的title和alt属性的区别是什么？ alt是图片属性，让搜索引擎认识你的图片，当图片不显示的时候显示 title是网站的标题，是SEO中最重要的属性 14. 使用css图片精灵有什么好处？ CSS图片精灵将一张张小的图片整合到一张大的图片上，减轻HTTP的请求数量。 15. 什么是语义化的HTML？ 标签使用的合理性，对于搜索引擎的抓取有好处 16. b标签和strong标签，i标签和em标签的区别？ 后者有语义 前者则无 17. title与h1的区别？ title侧重网站的信息标题 h1侧重于文章主题 站在SEO的角度来看，好网站少不了title，好文章少不了h1标题，title权重高于h1 18. 清楚浮动的几种方式，各自的优缺点？ 1.使用空标签清楚浮动clear:both(缺点：增加无意义的标签) 2.使用overflow:hidden;(使用ZOOM等于1 用于兼容IE) 3.使用after伪元素清楚浮动（适用与非IE浏览器） 19. display:none 和 visibility:hidden的去别是什么？ visibility:hidden;将元素隐藏，但还是占着位置 display:none; 将元素的显示设为无，不占任何位置 20. 说出几种IE6 BUG的解决方法？21. 域名和服务器的相关知识？ 域名：www.baidu.com 服务器：后台处理程序以及数据库（对客户端的请求进行相应的响应） IP地址指向域名 192.168.1.1——》www.baidu.com 22. HTTP状态码都有哪些？ 200OK 客户端请求成功 400Bad Request 客户端请求有语法错误，不能被服务器所理解 403Forbidden 服务器收到请求 但是拒绝提供服务 404Not Found 请求资源不存在 输入了错误的URL 500 Internet Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能回复正常 23. 如何优化网页加载速度？ 1.减少css、js的文件数量和大小（减少重复性代码，代码重复性利用），压缩CSS和JS代码 2.图片的大小 3.把CSS样式表放置于顶部，把JS放置于页面底部 4.减少http的请求数 5.使用外部的js和css 24. position属性absolute和relative的区别？ absolute绝对定位 相对于浏览器定位 relative相对定位 相对于前面的容器进行定位 25. HTML5有哪些新标签？26. CSS新增伪类有哪些？ p:first-of-type p:last-of-type p:only-of-type p:only-child p:nth-child(2) :enabled、:disabled 控制表单控件的禁用状态 :checked 单选框和复选框被选中 27. 全局变量和局部变量有什么区别？28. 谈谈 this对象的理解 this是js的一个关键字，随着函数的使用场合不同，this 的值会发生相应的变化。但是总有一个原则，那就是this指的是调用函数的那个对象 this 一般情况下，是全局对象Global。作为方法调用，那么this就是指这个对象 29. document.write和innerHTML有什么区别？ DOM的innerHTML是DOM元素对象的一个属性 而write是document对象的一个方法 30. JSON是什么？ JSON是一种轻量级的数据交换格式。它是基于JS的一个子集。数据格式简答，易读写，占用带宽小。 {‘age’:12,’name’:’winter’} 31. ajax是什么？ajax的交互模型？同步和异步的区别？ 1.通过异步模式，提升了用户体验 2.优化了浏览器和服务器之间的传输，减少了不必要的数据往返，减少了带宽占用 3.Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载 二、ajax的最大特点是什么？ Ajax可以实现动态不刷新(局部刷新) 三、ajax的缺点? ajax不支持浏览器的back按钮 安全问题 ajax暴露了与服务器交互的细节 对搜索引擎的支持比较弱 破坏了程序的异常机制 不容易调试 32. 你常用的JS框架33. 工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量的完成工作？34. 介绍项目经验、合作开发、独立开发35. 开发过程中遇到的困难，如何解决？36. 对前端界面工程师这个职位是怎么样理解的？它的前景会是怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 1、实现界面交互 2、提升用户体验 3、有了Node.js前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从90分进化到100分，甚至更好。 参与项目，快速高质量完成实现效果图，精确到1px 参与团队成员，UI设计，产品经理的沟通 做好的页面结构，页面重构和用户体验 处理hack，兼容、写出优美的代码格式 针对服务器的优化、拥抱最新的前端技术 其他相关的加分项 都知道和使用过哪些编辑器，都使用和了解过哪些日常工具？ 都知道有哪些浏览器内核？开发过的项目都兼容哪些浏览器？ 瀑布流布局或者流式布局是否有了解？ HTML5都有哪些新的API？ 都用过什么代码调试工具？ 是否接触或者了解过重构？ 你遇到比较难的技术问题是什么？你是如何解决的？ 什么叫优雅降级和渐进增强？ 优雅降级/平稳退化： Web站点在所有新式浏览器当中都能工作，如果用户使用的是老式浏览器，则代码会检查以确认他们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验，却不至于完全失效。 渐进增强： 从被所有浏览器支持的基本功能开始，逐步的增加那些只有新式浏览器才支持的功能，向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自地呈现出来并发挥作用。 跨浏览器，网页性能优化，seo，深刻理解Web标准，对可用性、可访问性等相关知识有实际的了解，包括代码的可维护性、组件的易用性、分层语义模板和浏览器分级支持等。]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用命令行和github交互]]></title>
    <url>%2F2017%2F04%2F24%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8Cgithub%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[全局配置1234567初次配置git环境时需要进行的步骤：(配置过之后不需要再次配置)git config --global user.name &quot;Gwemz&quot;git config --global user.email &quot;3396543978@qq.com&quot;git config --global push.default simple clone一个已有的仓库做开发12345678git clone https://github.com/Gwemz/myblog.git .(将项目克隆到当前文件夹下)git --help //git相关命令查询git status //查看项目的状态(是否更新)git add * //添加需要更新的所有内容git status git commit -m &apos;myblog&apos; //每次提交的标注git push //提交(需要输入用户名和密码) 管理分支(除了 https://gwemz.github.io 之外其它 https://gwemz.github.io/myblog 如果需要访问则必须进行下述操作) 1234567git branch gh-pagesgit checkout gh-pagesgit merge mastergit push --set-upstream origin gh-pages 注意 多使用git status 查看自己目前所在的分支]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java环境配置eclipse的安装]]></title>
    <url>%2F2017%2F04%2F24%2Fjava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEeclipse%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[- java基础语法教程教程链接 - JDK环境配置 配置教程 - eclipse for JavaEE的安装 安装教程 - eclipse教程 教程链接 - 使用Tomcat搭建本地服务器 使用链接 - Java与MySQL连接 连接教程 - SQL Sever环境配置（安装SQL Sever数据库）- 解决命令提示符输入命令无反应的情况： 解决方法 - win10打开管理员命令提示符： windows+X——》命令提示符（管理员） - 解决win10无法更新组件的问题：(下载.NET Framework 3.5安装错误：) 解决方式一 解决方式二]]></content>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提升你的面试机会？]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E6%9C%BA%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[本文转载于stromzhang博客 原文链接 最近太多人给我留言，说投了好多简历石沉大海，杳无音信，感觉都要放弃编程了，还有人给我留言，说自己是培训机构出来的，老师让学生们伪造简历，说大家都这么干的，而自己对伪造简历这种行为很不耻，但是不伪造又很难找到工作，很困惑，不知道该怎么办？好吧，今天我就来给大家写篇文章解答下，顺便教教你们如何提升你的面试机会。 绝不要伪造简历首先说说培训机构教学员伪造简历这件事，貌似现在已经成培训行业潜规则了，培训出来之后教学员伪造简历说 3 年工作经验，这事不是谣言，我自己面试就有亲自经历过。现在大家应该都知道，IT 行业对培训出来的人很抵触，很多企业看到简历上写培训出来的，基本就不考虑了。为什么？难道培训出来的人就低人一等？我想不是，主要就是这个行业环境被培训机构玩坏了。 培训机构基本就是看哪个行业火，哪个行业有利可图，然后疯狂的招生，学费还贵的要死，前两年的移动端开发就是一个鲜活的例子，而如今行业不景气，就开始教学员伪造简历，就在培训的时候做了一些小 demo，简历上能被包装成有过 2、3 年左右的大型项目工作经验，真把企业技术面试官当成跟他们一样傻了？ 可以这么说，有没有过工作经验，什么技术水平，技术面试官问几个问题就基本都清楚了，因为他们面试过太多的人了，见识过各种各样的面试者，技术层面想忽悠过去基本不太可能。当然按照概率的话你是有可能遇到一个人傻钱多的公司，你成功的忽悠过 HR、技术 Leader、CTO、CEO 等，这也算你有本事，但是伪造简历这么低级的行为都没能识破，那这家公司也基本没什么前途了。 伪造简历被识破事小，关键很有可能拉入黑名单。举个例子，如果你投递阿里，被发现伪造简历，那么将拉入黑名单，你之后技术提升了，再想加入阿里可能都没机会了，不止工作经验，简历上你的基本信息、教育经历、工作经历等通通都要真实有效，因为稍微正规点的公司在入职前都会做背景调查，背景调查一方面防止你跟之前公司没有劳务纠纷，另一方面就是为了确保你提供的信息真实有效，往小了说是诚实的问题，往大了说就是人品与价值观的问题，而人品远比技术重要的多的多！ 所以，无论任何时候，都不要伪造自己的简历！ 可以适当的包装下自己的简历一般来说企业的面试流程是由 HR 先筛选一遍简历，然后再把筛选过后的简历提供给技术部门，但是 HR 通常是不懂技术的，所以 HR 筛选简历一般会按照一些硬性的标签进行筛选，比如 「2 年工作经验」、「985/211」、「本科以上」等之类的进行标签筛选，因为通常一份 JD 发出去，招聘网站上会有一大堆简历过来，先由 HR 进行一轮筛选是比较有效的方法，但是必须承认这种粗略的筛选肯定会错过一些人才的，比如确实有一些牛人就不是本科学历，但是无所谓，没有一种办法能百分百的公平，企业会按照他们自己认为最有效的方式进行筛选，也许会错过很多优秀的人才，但是企业只要能找到他需要的人才就行了。 然而很多人可能在第一步 HR 的筛选就被略过了，所以这个时候适当的对简历进行包装下也不是不可以，但注意，适当的包装不是恶意提供虚假信息的伪造，性质上是不一样的。 比如你确实只毕业一年，有一年的工作经验，但是你在毕业之前有过半年多的实习经验，这个时候我觉得可以把实习经验也算作工作经验中来，当然前提是你真的是实习过，而不能伪造你的实习经历。 如果你自认能力特别强，工作经验也可以多说点。比如我曾经见过一个一年工作经验的人，简历上写着 2 年工作经验，我问他：为什么你只毕业一年就有两年的工作经验呢？他回答说：这一年天天在加班，那一年工作经验是加班加出来的。一开始我以为是伪造简历，后来聊了聊发现这人的能力确实很强，而且接触到的领域很广泛，完全不像是一年工作经验的，了解到这一年来他加班不只是单纯的做项目，有时候加班也是在做技术研究，提升自己，这个时候虽然知道他有点伪造简历的嫌疑，但是毕竟能力在这摆着，并没有给人一种很浮夸的感觉。当然，前提是此人能力确实很强，否则的话可能根本不会继续聊下去，所以不要轻易模仿。 另外在项目经验上，很多人说没工作过，简历没有项目经验可写，在简历上项目经验是非常重要的一环，可以说是最重要的一部分，没项目经验在现在的环境很难找到工作，如果真的没项目经验可写，那么完全可以写上自己练手过的项目，或者自己模仿的一些作品，都可以算作项目经验，这也可以算是在可接受的范围内一种包装自己简历的方式。 尽量不要海投大部分人找工作都是在一些招聘网站海投，其实这是很没有效率的一种做法。建议有针对性的投递，比如每次选 10 家看着不错的公司进行投递，没有音信了再选择另外一批，这样做的好处是更加有针对性，于企业、于自己都是更有效率的方式，而且这种方式选择公司环境与岗位职责真的适合自己的企业，另一方面万一第一轮筛选过了，要你去面试也不至于对这家公司一无所知。 一股脑的海投倒是省事了，但是你没有任何准备与期待，自己技能与公司要求不匹配只会浪费双方的时间，这种做法无疑病急乱投医。面试这件事本身是需要你专门花时间去做准备的，准备越充足，机会才能更加青睐于你。 另外，这里推荐大家到一些新兴互联网招聘平台投递，传统招聘平台不管是公司质量还是招聘效率、体验都没法比。这里推荐几个：拉勾、哪上班、简寻、100offer、BOSS直聘等，具体地址请自行搜索。 优先内推其实最快最有效然后又确保百分百不会被 HR 略过你的简历的方式是内推，所以如果你想加入一家公司，你尽量从朋友、同事、学长、朋友的同事的朋友中争取到内推机会，所以这里体现出了你平时的人缘与积累的人脉了。当然内推也只是能保证你的简历一定能被面试官看到而已，但是能不能通过面试还是得看自己的技术能力。 主动自荐如果你没有内推资源，但是又不想跟其他所有人一样海投，那么我建议你主动争取机会，也就是自荐。在了解到一家公司招聘之后，你在网上想办法得到这家公司的技术 Leader 的邮箱，不管是微博、博客、GitHub、还是招聘网站等，总之技术人的邮箱一般还是有办法得到的，发邮件给他，附带上自己的简历。 但是我要提醒你们的是，那些只发自己简历一句话介绍都没的人，基本跟海投一样，机会很渺茫。你应该在邮件的正文里简单的介绍下自己，并且表达对该公司的认可与热情，最好还能了解下该公司的业务，或者对产品提出自己的一些意见，这些都会提高你被技术面试官发现的概率。一般来说，直接发给技术面试官的求职信还是蛮少的，所以这种情况技术面试官都会看一下你的简历的，如果简历符合他们的招聘需求，则会要求 HR 联系你的。 比如，我曾经就收到过一封邮件，邮件里除了他的简历外，还对我家产品提出了非常有价值的建议，一下就吸引了我的注意，后来经过层层面试，技术能力也很不错，在技术能力差不多的情况下，我们优先录取了他。因为对企业来说，直接发给技术面试官自荐信起码说明了自己很主动，还对产品提出了建议，说明了对公司了解很多，做了不少准备工作，如果你还关注了这家公司很长时间，表达出了特别期待加入的热情，通常来说入职自己向往的企业工作后会很有激情，并且很积极主动，很有冲劲，而企业大多都喜欢招聘这样的员工。 最后，以上就是我能想到的能帮助你们在茫茫简历中脱颖而出的一些点，希望能提升点你们的面试机会，祝大家都能找到一份心仪的工作！]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何脱颖而出]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%A6%82%E4%BD%95%E8%84%B1%E9%A2%96%E8%80%8C%E5%87%BA%2F</url>
    <content type="text"><![CDATA[如何脱颖而出 版权声明：本文为 winter文章，可以随意转载，但必须在明确位置注明出处！！！ 前两天有一位同学在小密圈里问我一个问题，说自己高中学历，想要学习编程，不知道可行么？ 我给他的回答是：很难，非常难，比你想象的还要难，但是难不代表不可行。 有别的热心的同学评论说，没什么不行的，只要比别人更努力就行，你看张哥，当初不也是非科班，学渣出身么，一步步靠自己努力走到现在。 是啊，很多读者喜欢拿我的经历来激励自己，我毕业转行做开发的时候，已经比同龄人落后太多太多，中间有过不少波折，但是走上正轨，确定方向之后，很快 2、3 年的时间就取得飞快进步，并且在业内也积累了一点名气，之后又从技术到产品、管理，业余时间从写博客，再到公众号，都取得了点小成就，大家都知道我很努力，甚至到拼命的地步，所以，很多人把我取得的成就全部归功于我的努力，其实，今天，我要说，这是一个假象！ 不可否认，努力固然重要，但是如果只是单纯努力的话，我相信这世界上努力的人随处可见，这世界从来不缺努力的人，但是，如何能在这一群努力的人中间，脱颖而出，这才是一个关键点，今天，我就在这里分享下我私人总结的一点经验。 1. 提高自己的起点 不管你是高中学历也好，还是跟我一样非科班的学渣也好，其实本质上我们的先天条件比别人差，时间周期也比别人晚，我们要想赶上那些先天条件比我们好的同学，比他们更努力，虽然可以赶上一部分人，但是很多条件好，同样很努力的人比比皆是，这个时候，就需要寻找点方法了，我总结的第一个方法就是–提高自己的起点。 举个例子，我们大部分人学习编程的时候，大都是看视频、百度、CSDN 博客、一些国内论坛等，可以这么说，即使是现在，这仍然是大部分人学习的主要方式。但是我当时就不这么想，大家都这么学习，我如何才能效率更高呢？ 所以，我当时的做法，当别人都在看视频的时候，我坚持看博客、文档学习，因为看视频很没效率，看博客除了节省我的学习时间之外，还提高了我的阅读能力。当别人在用百度，查看国内各种二手资料的时候，我坚持使用 Google，查看国外大牛博客，我英语很差，这对我来说很难，但是我硬逼着自己，坚持下去，当别人混国内小白论坛的时候，我就开始混 GitHub 开源社区，学习国外大牛的开源项目，当别人在看国内翻译的资料的时候，我却逼着自己去官方看英文文档。 这一切的一切，本质上都是为了提高自己的起点，虽然我起步晚，但是我起点高，慢慢的就会缩小差距，时间长了，甚至后来居上。 当然，前提是自己得衡量自己的能力，就好比，你才刚学会写一个 Hello World ，你说你要去看 Android 源码，这不现实。所以，我在最初入门的时候也经历过看视频，百度的阶段，但是一旦自己上手之后，我坚定的逼着自己让自己的起点更高。 2. 保持专注 很多人其实论努力程度不输任何人，但是总感觉自己进步非常慢，那么原因很可能是你不够专注。我看到这么一个现象，IT 界技术日新月异，动不动就会出来一门新语言，新框架，尤其前端界更是，很多人就看到有一个看似很火的东西出来了，然后去学习，另一个东西出来了，又忙不迭的去学习，生怕错过了时间窗口就错过了巨大的机会。 然而殊不知，万变不离其宗，你连手上的事都没做好呢，就想着可能会错失巨大的机会，在编程界，其实各个语言都是通的，把一门领域学好学精，后面再涉及其他领域也是很快速的。 有人可能会问，不紧跟时代潮流，错过了机会怎么办？ 潮流固然要关注，但是我敢这么说，你连手上的事都还没做好呢，即使机会来了，一样不属于你。我们总是夸大了时间窗口的作用，以为错过了互联网、错过了移动互联网，决不能错过下一个风口浪尖了，这真的是一个误区，看似每一个风口来了，抓住机会的都是第一时间进入的，殊不知，第一时间死掉的比存活下来的不知道要多出多少，能存活下来的，只是被人忽略了自身的实力而已，而且很多后来居上的例子数不胜数。 所以，你不妨专注在一件事上，专注手上正在做的事，就如我博客所说：做好现在的事！ 3. 把事情做到极致 这世界上很多人都很专注，甚至有几十年如一日在自己的工作岗位上兢兢业业，但是专注在一件事上还不够，你要把事情做到极致才行。 这个特质对很多职场中的同学非常有用，很多刚入职场的同学总是感觉自己做的工作没什么用，就是打杂的，抱怨自己被大材小用了，然而，就是这么简单的工作，你能把它做好，做到极致，一样很有价值，你也才能因此得到更多的机会。 我刚加入公司的时候，甚至做过一段时间的「电话管理员与网管」，公司每每调换座位的时候，我从来都是利用下班时间帮大家调换电话线，我每次都会亲自验证，要知道很多电话不在同一楼层，这非常麻烦，但是从来没出过错，人事都觉得不可思议，因为之前的人负责的偶尔调错很正常。除此之外，我觉得机房里那些电话线非常混乱，杂乱无章，专门重新做了整理，这些工作，在之前，没人愿意去做。 我在给别人重装系统的时候，每次都会把驱动、常用办公软件一并给装好，之前，也从来没人想过这事。 正因为我把在公司的每件事都做到极致，我才能因此得到更多的信任与机会。 现在我在公众号写作，除了内容之外，我会力求把所有细节都做好，字体大小、标点、间距排版等等，我都会很在意，直到现在也一直在改进。 很多人总觉得自己工作做的还不错，分配的任务做完了，总觉得没事做，然而问问你自己，是否还可以做的更好？ 这个功能是不是还有更好的实现方式？代码是不是还可以更简练些？这个动画是不是还可以更流畅些？是不是有些历史遗留问题可以解决的？有些更好的框架是不是可以考虑学习应用在项目中？性能是不是还可以更好些？ 任何一件小事，做到极致，都是一项了不起的能力！ 4. 不要给自己设限 之前有人问我这么一个问题，说之前一直做技术 Leader 的角色，公司觉得他做的还不错，想让他做项目管理，他很纠结，担心自己做不好，而且还影响了技术上的进步。 如果是我，我会毫不犹豫的尝试。 很多人知道我，我自己是从一位不起眼的程序员，一步步走到公司管理层的，我现在参与公司的重大决策，现在除了技术之外，我涉及到的领域非常多，有产品、运营、商业、管理、投资等。 我当初一样面临过这种选择，一样犹豫过，一样有各种担心，但是当我走过来，我才明白我自己的职业选择都是来自于我的一个特质：我从来不给自己设限。 我自己的性格比较开放，喜欢折腾，喜欢接触不同的领域，有很多奇特的想法，比如我认为现在国家规定一个人只能同时在一家公司上班不科学，我认为未来是一个多元化人才的时代，一个人如果只要有能力，在一家公司写代码的同时，为什么不能同时在另一家公司做销售呢？只不过时代还不认可我这么前卫的想法。 但是，只要有机会，我都会接触不同的领域，我不会优先考虑我做不到，我只会先考虑，如果我做到了，会不会对自己的能力有很大帮助。 所以，当我有一个工程师转到管理岗位的机会时，我尝试了，毕竟，万一尝试之后，不适合自己，或者自己做不到，又能如何呢？大不了再做回老本行好了。幸运的是，我成功了，而且一直做到公司管理层。 除此之外，我还经常跟公司产品经理一起讨论产品，有很多不错的需求甚至都是我来提出的。由于我自己在公众号的运营经验，我有机会还教下我们的媒体运营同事，如何排版，如何更好的运营用户等。 我说我在商业、投资领域也有涉及，很多人可能觉得我又扯淡了，这些都是我在老板身边学到的，老板是投资出身，在这方面很厉害，毕竟呆的时间久了，自己总会有所感染，而且在去年还跟着老板一起在上海投资了一家吐司店，一年多的时间，估值翻了将近十倍，当然，由于自己第一次投资，还没什么经验，投资额度较小。 这个世界从来都是有得必有失，我做了管理之后，在 Android 技术领域上花费的时间很少了，也不用自己写代码了，但是我在其他领域的能力收获非常大，我也一直在向我口中所说的多元化人才努力。 有人可能会有疑问了，不给自己设限不跟上面说到的专注矛盾么？ 当然不矛盾，不给自己设限的前提一定是自己具备了至少一项不错的能力，而且即使你再怎么专注，也没法一天 24 小时都在做一件事，即使你很专注，你也会有看电视、娱乐的时间。 所以，专注的做好手上的事固然很重要，但是不要闷头工作，也偶尔抬头看下外面的天空，拓宽下自己的视野，在有其他领域机会的时候，不妨勇敢的去尝试下。 5. 执行力 我们都知道努力很重要，但是很少有人能做到。 比如，即使我一而再再而三的号召大家，要写博客，学写作，又有几个人做到了呢？你知道，每天只需要学习 2 小时，一年之后，你的能力就有很大提高，又有几个人能做到？ 所以，大部分人的执行力很差，可能你一时做到了，也没法坚持下去，而把自己的执行力持续下去恰恰是最关键的一环，也就是所谓的：「道理我都懂，可是我做不到」。 这个话题很长，后面我会抽时间单独写篇文章，以自己的亲身经历总结了一点方法，教教大家如何才能改变这一现状，提高你的执行力，让你的努力更容易坚持下去。 以上，就是我所总结的，如何让你脱颖而出的一些技巧，希望对部分同学有所思考与帮助！ PS：可能有些人，看了以上我的总结，会觉得，这些东西我都知道，但是，真的是这样么？我敢说，在你没看这篇文章之前，你丝毫没有意识到自己比别人差在哪里，你只是看了之后，恍然大悟罢了。 还有些人，可能会觉得是鸡汤，某种意义上来说，确实是鸡汤，但是却都是自己真实经历的经验总结，有时候，鸡汤可能比所谓的干货更有用，很多道理其实大家都懂，我们做出改变缺乏的只是一个推动力。]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发面试题二]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[HTML 行内元素关注行内置换元素，类似inline-block方式展现 input textarea img select 浏览器内核基于 Webkit:Chrome-blink 、腾讯X5、UC U3 、华为T9 基于 Gecko：Firefox 基于Trident：IE 基于 Presto：Opera 兼备Webkit&amp;Trident：猎豹、360 W3C标准包括结构(xhtml、html)、表现(css)、行为(ecmascript、dom)的标准。更好的规范浏览器渲染页面，使得同一套网页规范尽可能在多套浏览器中表现一致。提高开发者开发效率和用户体验。 Doctype用来告诉浏览器以什么文档类型解析html，没有的话，会按照向下兼容的怪异模式进行解析。 h4及以下需要引用dtd声明，dtd有标准型和过渡性两种。两者区别可忽略 h5不急于SGML标准，因此不需要引用dtd 标签语义化的重要性1.便于浏览器 搜索引擎解析 2.在没CSS情况也以一种文档形式展现，便于阅读 3.有利于SEO 4.有利于代码的阅读和维护 strong与em的异同同：都是对文本起强调作用 异：em以斜体展示文本，strong更利于SEO识别语义 SEO 详细可分为白帽SEO和黑冒SEO SEO的主要方面1.网站标题、关键字、描述(meta) 2.网站结构布局优化：目录层级不要太多，尽量让Spider跳转3次就可以到达网站的任何一个内页 3.网站代码优化 SEO会过滤掉display:none的元素、利用]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hold on or give up!]]></title>
    <url>%2F2017%2F04%2F22%2Fhold%20on%20or%20give%20up%2F</url>
    <content type="text"><![CDATA[前言不知不觉来杭州已经快一个月了，投了不少简历，也面试了一些公司，总体来说，目前还是一名无业游民。说不着急那不太现实，毕竟每天都是开销，吃饭、住宿、交通费用等等，但是感觉着急也没什么用，每天也是稀里糊涂、漫无目的看看别人写的博客，看stormzhang的博客较多,也会帮别人研究研究一些新的知识点，如果感觉自己有什么困惑的时候也会随时记下来，当成自己的一篇博客文章。目的不是为了别人看，而是让自己下一次不要再犯同样的错误，毕竟，在我身上，掉进同一个坑也不是一次两次了。 这段时期也是有很多的感慨，因为有好多同时期的同学，在步入社会后也是在这一时期遇到了各种各样的困惑。在同期接触这一行业的同学中，有的在思维逻辑方面的能力要远胜于自己，但是选择放弃了这一行，因为行业的特殊性对于一个女孩子来说确实很辛苦；做测试的同学告我他经常夹在客户和开发人员中间被各种挑毛病进而两方周旋，也是在考虑要不要换一份工作；工作了一年的同学这段时期也是有的选择离职回家考公务员，有的离职去北上广大城市寻求更大的一个就业机遇；还有的同学正在考虑要不要进入这一行。 说实话，在聊到这类型的话题时，我不知道该怎么回答，因为现在的我也在找工作阶段，我并不是一个过来人，我的困惑甚至可能更多，我只是一只菜鸟，一只也是不知道何去何从的菜鸟。每个行业都有每个行业的苦楚，即将大学毕业的我们也是面临社会生存的等等各种各样压力。每次谈到这样的话题时，我总会说的一句话便是“随着自己的心走，怎么想的就怎么来，只要自己觉得可以就行，没必要考虑别人的想法，因为事情都是我们自己来经历，别人体会不到你的想法，更没有资格发言！” Hold on or give up?坚持还是放弃？谁都不能干涉别人的想法，我想我能做的便是尊重每个不同的意愿，人生这么长，每个人身上都有无数种可能性，那么这一行放弃并不代表人家在另一行业就不能成功。那么对我而言，从内心深处可能还是没有想过放弃，或者是不甘心，可能我这人是比较轴或者是内心还有点盲目的小自信？ 对我而言，作为一名front-end developer，深知自己的欠缺之处，技能方面在业务逻辑处理方面还较差，我想对业务逻辑方面的技能加强是现阶段最先要着手处理的任务。 其次，做事还是有很严重的拖延症，任务一拖再拖，今天的事总是拖到明天或者后天，直到最终截止日期才着急忙慌，这样完成的任务一定不是心里边想要的那个效果，而一个较完美的项目一定是一个耗费很长时间很多心血的项目。 最后，每天的任务没有一个明确的规划，总是想到什么便做什么，由着自己的性子来，经常是这儿看看，那儿看看，到头来发现什么都没解决掉，就像小时候那一只捡了芝麻丢掉西瓜的猴子，到头来什么都没得到。 How to solve it?依照自己所具备的三个不足，提出相应的解决方案，毕竟总得不时的反思自己的功与过，不然永远也没法进步不是么？ 第一、专注自身在业务逻辑方面的培养训练。 第二、每一件任务规定好一个时间段，该工作时工作该娱乐时娱乐，二者最好不要有任何的冲突。 第三、在每一天打开电脑的时候为这一天制定一个工作计划，在晚上工作结束之后再填写填写自己工作的完成情况。]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桃花源记]]></title>
    <url>%2F2017%2F03%2F18%2F%E6%A1%83%E8%8A%B1%E6%BA%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷，渔人甚异之。复前行，欲穷其林。 林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。 见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。” 既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。 南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终，后遂无问津者。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗汉篇]]></title>
    <url>%2F2016%2F03%2F18%2F%E7%BD%97%E6%B1%89%E7%AF%87%2F</url>
    <content type="text"><![CDATA[十八罗汉 戎博迦尊者(Gopaka)戎博迦尊者为十八羅漢的第九位，為梵語Svaka的音譯。意「賤民」，可見他的出身低微或曾被閹割為宮中為奴。戍博迦原是舍衛城的乞丐，後為佛陀收留為弟子，深感佛陀法力無邊，很快修成阿羅漢果，被稱為「開心羅漢」。 伐那婆斯尊者(Vanavasin)十八罗汉的第十四位，为梵语 vanavasin的音译。伐那婆斯尊者是一个沉静有礼，谦虚好学的人。他静心听讲，不但佛陀说的，而且其它人说的都用心去听，有一次，弟子们都在听目连尊者说法，目连说了四句佛偈;「诸恶莫作，众善奉行，自净其意，是诸佛教。」这四句概括了佛教的的宗旨。伐那婆斯深受启发，后他深思好学，很快就得了阿罗汉果。 由于他常在芭蕉下用功，故又称「芭蕉罗汉」。 诺矩纙尊者(Nakula)十八罗汉的第五位，为梵语 nakula 的音译。他出家前是艺名勇猛的战士，后来出家，佛陀让他静坐，放弃从前当士兵时的那种粗鲁，野蛮性格。但他静坐时仍显出大力士的体魄。所以他又称「静坐罗汉」。 加力迦尊者(karika)十八罗汉的第七位，为梵语 karika 的音译。他是佛陀的一名侍者。他本是一位驯象师。象的力量非常大，耐劳又能致远，也是佛法的象征，所以世人称他为「骑象罗汉」。 跋陀罗尊者(Bhadra)十八罗汉-意为「贤」，他是佛陀的一名侍者。传说他主管洗浴事，有些禅林浴室供其相。跋陀罗的母亲怀孕临盆时把他生在了跋陀罗树下，所以给他取名为跋陀罗，跋陀罗出家后称为罗汉。据称，他曾乘船去东印度群岛传播佛教，因此后世称他为「过江罗汉」。 半托迦尊者(Pantaka)一大富长者的女，与迦奴私通，逃到别国，久而有孕，临产思归。于中路产子，如是覆生第。长名「摩诃般陀」，弟名「周罗般陀」。译成汉语，兄叫「大路边生」，弟叫「小路边生」。兄聪明弟愚钝，后二人皆修成罗汉。半托迦是兄，弟叫「注茶半托迦」，为第十六罗汉。半托迦打坐时常用半跏跌坐法，打坐完毕即双手举起，长呼一口气，又称「探手罗汉」 达摩提那尊者十八罗汉-传说伏虎尊者所住的寺庙外，经常有猛虎因肚子饿长哮，伏虎尊者把自己的饭食分给这只老虎，时间一长了猛虎就被他降服了，常和他一起玩耍，故又称他为「伏虎罗汉」。 囉怙羅尊者(Bakula)十八罗汉-因揭陀生于中印度一首相之家，是首相的独子，但他却没有因此而贪图享受，他一心想出家，但却遭到家里的反对，几经辛苦终于在他的国王的帮助下跟佛陀出家了。 迦诺迦伐蹉尊者(Kanakavatsa)十八罗汉-在一次偶然的机会下，佛陀遇到迦诺迦伐蹉虔诚地礼拜，迦诺迦伐蹉见到佛陀感到很高兴，佛陀为他讲了「四种结业」(即杀生，盗窃，邪淫，妄言) 。「四处恶行」(即永无满足之自私的贪欲，忌妒交狂之恼怒的嗔恚，所做行业之后果的恐惧，执断执常知己见的愚痴)和「六种不应做的事」「即嗜酒，好赌，闲荡，沉迷歌舞，爱交恶友，懒惰)…等等。迦诺迦伐蹉听后，茅塞顿开，成了佛陀的弟子，并证得阿罗汉果。又被后人称谓「喜庆罗汉」。 因揭陀尊者(Angaja)八罗汉-因揭陀生于中印度一首相之家，是首相的独子，但他却没有因此而贪图享受，他一心想出家，但却遭到家里的反对，几经辛苦终于在他的国王的帮助下跟佛陀出家了。 迦诺迦跋厘惰阇(Kanaka-Paridhvaja)十八罗汉-尊者名迦诺迦跋厘惰阇，中国本来没有[钵]字，这个[钵]字是从梵文中的[钵多罗]中取第一音而创出来。钵是和尚用来盛饭菜的餐具，是用铁制成的，因此[钵]字从金，本字是拟声的字旁。迦诺迦跋厘惰阇尊者，是一位化缘和尚，经常向施主们乞讨，他的化缘方法是举起铁钵，向人们乞求。他修成阿罗汉果后，人称[举钵罗汉]。 宾头颅尊者(Pindola Bharadvaja)十八罗汉-彩石镶嵌作品宾头卢婆罗堕系释迦牟尼的四大声闻之一，十八罗汉的第一位，为梵语 pindolabharadvaja 的音译，又为 宾头卢婆罗堕，宾头等。意为「捷疾」。出身婆罗门贵族，原来是拘舍城优填王的大臣。他出家后，证得阿罗汉果。并以神通见长，他虽然是罗汉，但还爱在人家面前卖弄本事。据「十诵经」载，佛陀在王舍城时，树提居士将一木钵高高悬起，并声言若有沙门能不用梯杖取下此钵，钵便归其所有。尊者即入定，用神通力腾空而起取下木钵。佛因他在未受戒人面前妄自显弄神通，不准他入于涅盘，命他率一千阿罗汉常住人间，造福世人。 那伽犀那尊者(Nagasena)十八罗汉的第十二位，为梵语 nagasena。意「龙军」，常称「那先比丘」。是佛学理论家，二十岁具足戒，后修证阿罗汉果。那先比丘到古印度西北舍竭国见国王弥兰陀，应国王的问，以各种比喻广泛说明人生无常，善恶报应等佛法，以及佛教徒修行等问题，所有都载入《那先比丘经》里。是对佛教基本教义的最大阐发。 注荼半托迦尊者(Chudapantaka)十八罗汉-注荼半托迦尊者是第十位尊者「半托迦」尊者的弟弟，在半托迦尊者的接引下，注荼半托迦也跟着佛陀修行了，但注荼半托迦生来迟钝，出家四个月一句偈语也学不全，但在佛陀的精心点化下，不久也证德阿罗汉果。 布袋和尚尊者(Patron-Hvashang)布袋和尚尊者系五代的一位高僧。法名契此，又号长汀子。明州奉化（浙江）人。以神异着称，常用杖背负一只布袋入市，故称为布袋和尚。因他圆寂前说了「弥勒真弥勒，分身千百亿，时时示时人，时人自不识。」时人认为其为弥勒的化身。相传在中国多数佛教寺院里所供奉的大肚弥勒，即为他的造像。 阿氏多尊者(Ajita)阿氏多因长相异常丑陋，被父母赶出家门，只好出门行乞，但人们都被他的容貌吓着了，没人愿意施舍他。他只好藏入山林，靠山泉野果为生，但就连山中的鸟兽也怕他，，阿氏多孤苦伶仃地过着野人般的生活，佛陀知道后，就入山中度化他，阿氏多见到佛陀和比丘的身影就逃之夭夭。佛陀变成一位丑陋如鬼的人去接近阿氏多，阿氏多见到一个相貌跟自己差不多的人，先是惊讶，接着便高兴地说「我们都一样丑，一样寂寞，就做个好朋友把」佛陀说「好的。好朋友，我先敬你这钵中的饭吧 」阿氏多一听，便把饭吃光，当他吃完后，却见眼前的人变成了个俊秀的人。他奇怪的问为何他变成好看的人。佛陀指着远处在坐禅的比丘说;「我刚才吃饭时，恭敬的看着那位比丘坐禅，这恭敬的心得到果报，我就变得端正了。」阿氏多十分高兴的说;「要能这样就好了，丑人太苦，我真想变的端正些。」便恭敬地瞧着比丘坐禅。这时，佛陀现了他的真面貌，光辉遍体，端庄慈祥。阿氏多不由自主地跪在佛陀面前，请求出家，佛陀高兴的说;「好，我收你为弟子。」阿氏多在佛陀的身边，勤修苦学，不久就成了阿罗汉果，又称「长眉罗汉」。 阿秘特尊者(Abheda)苏频托尊者(suvinda)]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
